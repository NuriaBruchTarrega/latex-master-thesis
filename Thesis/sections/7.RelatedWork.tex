% !TEX root = ..\main.tex
\chapter{Related Work}\label{ch:RelatedWork}
In this chapter we present the work related to the topic of this thesis.
As far as we have been able to find, there are no papers that propose a way to measure dependencies between two software products. However, there is related work in the area of dependency management and software ecosystems modelling.

\paragraph{In Dependencies We Trust: How vulnerable are dependencies in software modules? \cite{hejderup2015dependencies}}
The thesis does a study of how the vulnerabilities in the npm packages impact of the JavaScript ecosystem. This is done by studying the dependency chain created by the vulnerable packages through the packages that depend on these. One of the main contributions of this research is the tool used to find the dependencies between the packages, to determine the impact of the vulnerabilities, \texttt{Rastogi.js}\footnote{\href{https://github.com/jhejderup/rastogi.js}{https://github.com/jhejderup/rastogi.js}}. The research determined that although only a 1\% of the modules are vulnerable, and that the dependency chain increased the number of vulnerable modules a 39.36\%.

In addition, the research includes a study of how these vulnerabilities are fixed, by updating to a new version of the package without the vulnerability. In particular, it focuses on the time needed for updating to a newer version. The results show that in 2013 there was a latency of several months, while the most recent pathes (at the time the thesis was done) needed about two weeks.

However, to determine the packages affected by a vulnerability with the \texttt{Rastorgy.js}, the strategy is still binary, looking at whether the package is included as a dependency or not. Therefore, there is no confirmation of whether the dependency is really used, or if the part containing the vulnerability is being exploited. In the conclusions, Hejderup states: \textit{"On the other hand, reports of a vulnerable dependency are not an immediate sign of a security weakness in a module. There are several factors to this: the module is used in a development environment, the vulnerable functionality of the dependency is not used, or there is a little risk that the vulnerability can be triggered."}. This points out the need for a more detailed analysis of the usage of the dependencies.

\paragraph{Impact Assessment for Vulnerabilities in Open-Source Software Libraries \cite{plate2015impact}}
Plate et al. create an approach to analyse whether an application depending on a library that contains a vulnerability is affected by it or not. Their methodology is meant to help assess the need to update the application with a version which does not use the vulnerable version of the library.

The methodology consists on comparing the parts of the library that are used by the application, with the parts updated in the library patch that fixes the vulnerability. It is assumed that those are the parts of the library containing the application. The parts of the library used by the application are defined based on a dynamic analysis of the application and the bundled libraries.

Although the use case of the research in this paper differs from the one of this thesis, the usage of static analysis performed with the metrics of the proposed model of the thesis, and the dynamic analysis done by Plate et al. can make a more accurate evaluation of both, the degree of dependency, and the probablility that a vulnerability is affecting the depending code.

\paragraph{Modeling Library Dependencies and Updates in Large Software Repository Universes \cite{Kula2017}}

\paragraph{PRÃ„ZI: From Package-based to Precise Call-based Dependency Network Analyses \cite{hejderup2018prazi}}

\paragraph{Software ecosystem call graph for dependency management \cite{hejderup2018software}}

\begin{comment}
\paragraph{Vulnerable Open Source Dependencies: Counting Those That Matter \cite{pashchenko2018vulnerable}} % This is the paper that talks about halted dependencies.
In this research, Pashchenko et al. propose a new method to count the dependencies of libraries. This method is used to analyse the dependencies of 200 libraries of the Maven ecosystem. With their method, they differentiate between libraries from the same project and third-party libraries. Furthermore, the dependencies that are not deployed in production (only used for testing or development purposes) are filtered out, since the vulnerabilities of this dependencies do not affect the final product. Furthermore, they consider the special case of halted dependencies, which are the ones that are not being actively developed. Vulnerabilities in halted dependencies suppose an important threat to the software project that depend on these, since the vulnerability is not going to be fixed.

One of the main contributions of this research is a tool implementing the method defined in the paper to detect the vulnerabilities that, according to their definition, matter.

However, Pashchenko et al. do not perform a call-level analysis of the dependencies, since their dependency resolution is based only on the \textit{POM} file of the libraries. Hence, the transitive dependencies that are not really used in the studied library are still counted.
\end{comment}

\paragraph{A Comprehensive Study of Bloated Dependencies in the Maven Ecosystem \cite{soto2020comprehensive}}
Soto-Valero et al. conduct a study of the unused dependencies included in the dependency tree of Maven artifacts. These libraries can be directly included in the dependency declaration file, or included by transitivity or inheritance.

One of the experiments conducted during the research, reported that a 75.1\% of the analyzed dependencies were unused dependencies. In this experiment Soto-Valero et al. used their tool \texttt{DepClean}\footnote{\href{https://github.com/castor-software/depclean}{https://github.com/castor-software/depclean}} to analyze the dependencies of 9,639 Java artifacts from Maven Central.
The tool \texttt{DepClean} analyses the dependencies of an artifact by creating a call graph of the API members of the libraries involved to define if a dependency is used or not.
