% !TEX root = ..\main.tex
\chapter{Related Work}\label{ch:RelatedWork}
In this chapter we present the work related to the topic of this thesis.
As far as we have been able to find, there are no papers that propose a way to measure dependencies between two software products. However, there is related work in the area of dependency management and software ecosystems modelling.

\paragraph{In Dependencies We Trust: How vulnerable are dependencies in software modules? \cite{hejderup2015dependencies}}
The thesis does a study of how the vulnerabilities in the npm packages impact of the JavaScript ecosystem. This is done by studying the dependency chain created by the vulnerable packages through the packages that depend on these. One of the main contributions of this research is the tool used to find the dependencies between the packages, to determine the impact of the vulnerabilities, \texttt{Rastogi.js}\footnote{\href{https://github.com/jhejderup/rastogi.js}{https://github.com/jhejderup/rastogi.js}}. The research determined that although only a 1\% of the modules are vulnerable, and that the dependency chain increased the number of vulnerable modules a 39.36\%.

In addition, the research includes a study of how these vulnerabilities are fixed, by updating to a new version of the package without the vulnerability. In particular, it focuses on the time needed for updating to a newer version. The results show that in 2013 there was a latency of several months, while the most recent pathes (at the time the thesis was done) needed about two weeks.

However, to determine the packages affected by a vulnerability with the \texttt{Rastorgy.js}, the strategy is still binary, looking at whether the package is included as a dependency or not. Therefore, there is no confirmation of whether the dependency is really used, or if the part containing the vulnerability is being exploited. In the conclusions, Hejderup states: \textit{"On the other hand, reports of a vulnerable dependency are not an immediate sign of a security weakness in a module. There are several factors to this: the module is used in a development environment, the vulnerable functionality of the dependency is not used, or there is a little risk that the vulnerability can be triggered."}. This points out the need for a more detailed analysis of the usage of the dependencies.

\paragraph{Impact Assessment for Vulnerabilities in Open-Source Software Libraries \cite{plate2015impact}}
Plate et al. create an approach to analyse whether an application depending on a library that contains a vulnerability is affected by it or not. Their methodology is meant to help assess the need to update the application with a version which does not use the vulnerable version of the library.

The methodology consists on comparing the parts of the library that are used by the application, with the parts updated in the library patch that fixes the vulnerability. It is assumed that those are the parts of the library containing the application. The parts of the library used by the application are defined based on a dynamic analysis of the application and the bundled libraries.

Although the use case of the research in this paper differs from the one of this thesis, the usage of static analysis performed with the metrics of the proposed model of the thesis, and the dynamic analysis done by Plate et al. can make a more accurate evaluation of both, the degree of dependency, and the probablility that a vulnerability is affecting the depending code.

\paragraph{Modeling Library Dependencies and Updates in Large Software Repository Universes \cite{Kula2017}}
In this paper, a model for library dependencies is created. The model is classified as a graph-based Software Universe Graph. It is focused on the updates of the dependencies and shows metrics such as the \textit{wisdom-of-the-crowd}. In addition, it is extended to describe the \textit{adoption-diffusion} and the \textit{co-dependency}. The \textit{adoption-diffusion} studies how the migrations to newer versions of a library are done. The \textit{co-dependencies} are libraries which are usually employed together in an application. This last metric is used to compare different super repositories, Github and Maven.

As described, the model of the dependencies is focused on the popularity of each version of the libraries, as well as the updates made in the dependencies of the different applications. Therefore, the analysis done is not fine-grained since the focus of the research is different.

\paragraph{PRÄZI: From Package-based to Precise Call-based Dependency Network Analyses \cite{hejderup2018prazi}}
Hejderup et al. create an approach to generate fine-grained call-level dependency networks, \textit{Präzi}. This approach is evaluates more precisely the dependencies between software products than a packag-level approach. As part of their work, the authors create an implementation of \textit{Präzi} for the Rust's \textit{Crates.io} ecosystem, called \textit{RustPräzi}.

With \textit{RustPräzi} and in order to demonstrate how effective the approach is, they perform two case studies. First, a case study which focuses on the propagation of the vulnerabilities accross software products, in which they prove the higher accuracy of their approach in comparison to a package-level dependency network. The second case study looks at the impact of deprecation in a library. In this case, with \textit{Präzi} they are able to perform an impact analysis of cleaning up deprecated functions.

In conclusion, they demonstrate the usefulness of a more fine-grained evaluation of the dependencies, and propose an approach to create a dependency network that allows this kind of evaluation. They do not propose a way to model the dependencies, but study two practical applications of the call-level dependency network.

\paragraph{Software ecosystem call graph for dependency management \cite{hejderup2018software}}

\begin{comment}
\paragraph{Vulnerable Open Source Dependencies: Counting Those That Matter \cite{pashchenko2018vulnerable}} % This is the paper that talks about halted dependencies.
In this research, Pashchenko et al. propose a new method to count the dependencies of libraries. This method is used to analyse the dependencies of 200 libraries of the Maven ecosystem. With their method, they differentiate between libraries from the same project and third-party libraries. Furthermore, the dependencies that are not deployed in production (only used for testing or development purposes) are filtered out, since the vulnerabilities of this dependencies do not affect the final product. Furthermore, they consider the special case of halted dependencies, which are the ones that are not being actively developed. Vulnerabilities in halted dependencies suppose an important threat to the software project that depend on these, since the vulnerability is not going to be fixed.

One of the main contributions of this research is a tool implementing the method defined in the paper to detect the vulnerabilities that, according to their definition, matter.

However, Pashchenko et al. do not perform a call-level analysis of the dependencies, since their dependency resolution is based only on the \textit{POM} file of the libraries. Hence, the transitive dependencies that are not really used in the studied library are still counted.
\end{comment}

\paragraph{A Comprehensive Study of Bloated Dependencies in the Maven Ecosystem \cite{soto2020comprehensive}}
Soto-Valero et al. conduct a study of the unused dependencies included in the dependency tree of other libraries in the Maven ecosystems. The research includes every type of dependency: direct, transitive and inherited from the parent module.

To conduct this research Soto-Valero et al. implemented \texttt{DepClean}\footnote{\href{https://github.com/castor-software/depclean}{https://github.com/castor-software/depclean}}. The tool analyses the dependencies of an artifact by creating a call graph of the API members of the libraries involved to define if a dependency is used or not, it is done through bytecode analysis. The output of the tool is a \textit{POM} file in which the unused dependencies are not included.

The research includes a comprehensive study of the unused dependencies in the Maven ecosystem, reported that a 75.1\% of the analyzed dependencies were unused dependencies. In this experiment Soto-Valero et al. used \texttt{DepClean} to analyze the dependencies of 9,639 Java artifacts from Maven Central.

The last contribution of the paper is a qualitative analysis to determine the interest of library developers to avoid unused dependencies. In this case, \texttt{DepClean} was used for certain open-source projects, and pull-request was created, in which the \textit{POM} file was changed for the one generated by the tool. 21 pull-request were answered by the developers, out of which 18 were merged.

In this paper, the focus is still binary, either a dependency exists or not. Nevertheless, the method used to determine the existance of the dependency is much more fine grained than just declaring the dependency or not.
