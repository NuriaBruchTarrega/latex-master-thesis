% !TEX root = ..\main.tex
\chapter{Related Work}\label{ch:RelatedWork}
In this chapter, we present the work related to the topic of this thesis.
As far as we have been able to find, there are no papers that propose a way to model dependencies between two software products. However, there is related work in the area of dependency management and software ecosystem modeling.

\paragraph{In Dependencies We Trust: How vulnerable are dependencies in software modules? \cite{hejderup2015dependencies}}
The thesis does a study of how the vulnerabilities in npm packages create a cascading-effect in the JavaScript ecosystem and how the vulnerabilities are fixed. This is done by studying the vulnerable packages' dependency chain through the packages that depend on these. One of the main contributions of this research is the tool used to find the dependencies between the packages, to determine the impact of the vulnerabilities in the ecosystem, \texttt{Rastogi.js}\footnote{\href{https://github.com/jhejderup/rastogi.js}{https://github.com/jhejderup/rastogi.js}}. The research determined that although only a 1\% of the modules are vulnerable, and that the dependency chain increased the number of vulnerable modules a 39.36\%.

However, in contrast with the dependency metrics developed in this thesis, determining whether a package is affected by a vulnerability with \texttt{Rastorgy.js} is binary evaluation, performed by looking if the package is included as a dependency or not. Therefore, there is no confirmation of whether the dependency is used, or if the part containing the vulnerability is being exploited, since there is no fine-grained evaluation of the dependency. In the conclusions, Hejderup states \textit{"On the other hand, reports of a vulnerable dependency are not an immediate sign of a security weakness in a module. There are several factors to this: the module is used in a development environment, the vulnerable functionality of the dependency is not used, or there is a little risk that the vulnerability can be triggered."}. This sentence points out the need for a more detailed analysis of the usage of the dependencies.

\paragraph{Impact Assessment for Vulnerabilities in Open-Source Software Libraries \cite{plate2015impact}}
Plate et al. create an approach to analyze whether an application, depending on a library that contains a vulnerability, is affected by it or not. Their methodology is meant to help assess the need to update the application with a version that does not use the library's vulnerable version.

The methodology consists of comparing the parts of the library used by the application with the parts updated in the library patch that fixes the vulnerability. It is assumed that those are the parts of the library containing the vulnerable code. The parts of the library used by the application are defined based on a dynamic analysis of the application and the bundled libraries.

In this work, the authors refer to application in the same way we have been using client library. Again, this work focuses only on the impact of vulnerabilities and how to fix them, while this thesis measures the degree of dependency. Moreover, instead of focusing on static analysis as in this thesis, they combine it with dynamic analysis to determine if the application uses the part of the library containing the vulnerability. Nevertheless, these two approaches can be combined to obtain more information about the dependency: while static analysis indicates how the code of the client uses the dependency, the dynamic analysis shows the actual execution, as well as how many times is each part of the application, and the dependency is executed. Just as in this thesis, Plate et al. use \textit{Javassist} for the analysis, since for their proof-of-concept, they focus on Java.

\paragraph{Modeling Library Dependencies and Updates in Large Software Repository Universes \cite{Kula2017}}

In this paper, a model for library dependencies is created. The model is classified as a graph-based Software Universe Graph. It is focused on the updates of the dependencies and shows metrics such as the \textit{wisdom-of-the-crowd}. In addition, it is extended to describe the \textit{adoption-diffusion} and the \textit{co-dependency}. The \textit{adoption-diffusion} studies how the migrations to newer versions of a library are done. The \textit{co-dependencies} are libraries which are usually employed together in an application. This last metric is used to compare different super repositories, Github, and Maven.

In contrast with this thesis, the model is not meant to give information about a particular dependency, but rather indicate the most popular libraries and versions, and how it changes. Therefore, the analysis done to determine whether there is a dependency is not fine-grained but binary. Just as in this thesis, Kula et al. focus on Java, particularly the Maven ecosystem.

\paragraph{PRÄZI: From Package-based to Precise Call-based Dependency Network Analyses \cite{hejderup2018prazi}}
Hejderup et al. create an approach to generate fine-grained call-level dependency networks: \textit{Präzi}. This approach evaluates more precisely the dependencies between software products than a package-level approach. As part of their work, the authors create an implementation of \textit{Präzi} for the Rust's \textit{Crates.io} ecosystem, called \textit{RustPräzi}.

With \textit{RustPräzi}, and to demonstrate how effective the approach is, they perform two case studies. First, a case study that focuses on the propagation of the vulnerabilities across software products, in which they prove the higher accuracy of their approach in comparison to a package-level dependency network. The second case study looks at the impact of deprecation in a library. In this case, with \textit{Präzi}, they can perform an impact analysis of cleaning up deprecated functions.

Hejderup et al. use the word package in the same way we use library in this thesis. Moreover, instead of using the Maven ecosystem for their research, as we have done, and most of the other papers of the domain, they use Rust and \textit{Crates.io}. Furthermore, to create the call-graph of each package, instead of doing a custom analysis, they use a previously existing tool (\textit{LLVM}\footnote{\href{https://github.com/llvm/llvm-project}{https://github.com/llvm/llvm-project}}).

\paragraph{Software ecosystem call graph for dependency management \cite{hejderup2018software}}
In this paper, Hejderup et al. propose extending dependency networks with a versioned call-graph. The authors describe the algorithms used to create the network and how to perform an impact analysis of the changes in a library. Their technique uses the commit time of the products to resolve the dependencies' version ranges, aiming not to miss dependencies with previous library versions. The authors evaluate their dependency network by generating an impact analysis of a particular security bug. The output of the analysis is the part of the dependency network that is impacted by the bug.

Therefore, in this work, Hejderup et al. propose a different approach to create call-level dependency networks, which considers each library's historical data. The focus of the research is an impact analysis of changes and bugs. Nevertheless, the dependency network could also have other applications, such as calculating the metrics proposed in this thesis. The prototype created by Hejderup et al. is focused on JavaScript and the \textit{npm} ecosystem. In this case, to create the call-graph, they used \textit{Jalangi}\footnote{\href{https://github.com/Samsung/jalangi2}{https://github.com/Samsung/jalangi2}}, which uses dynamic analysis.

\begin{comment}
%% I'm not sure whether to add this paper or not
\paragraph{Vulnerable Open Source Dependencies: Counting Those That Matter \cite{pashchenko2018vulnerable}} % This is the paper that talks about halted dependencies.
In this research, Pashchenko et al. propose a new method to count the dependencies of libraries. This method is used to analyze the dependencies of 200 libraries of the Maven ecosystem. With their method, they differentiate between libraries from the same project and third-party libraries. Furthermore, the dependencies that are not deployed in production (only used for testing or development purposes) are filtered out since these dependencies' vulnerabilities do not affect the final product. Furthermore, they consider the special case of halted dependencies, which are the ones that are not being actively developed. Vulnerabilities in halted dependencies suppose an important threat to the software projects that depend on these since the vulnerability will not be fixed.

One of the main contributions of this research is implementing the method defined in the paper to detect the vulnerabilities that matter according to their definition.

However, Pashchenko et al. do not perform a call-level analysis of the dependencies since their dependency resolution is based only on the \textit{POM} file of the libraries. Hence, the transitive dependencies that are not really used in the studied library are still counted.
\end{comment}

\paragraph{A Comprehensive Study of Bloated Dependencies in the Maven Ecosystem \cite{soto2020comprehensive}}
Soto-Valero et al. conducted a study of the unused dependencies included in other libraries' dependency tree in the Maven ecosystem. The research includes every type of dependency: direct, transitive, and inherited from the parent module.

To conduct this research, Soto-Valero et al. implemented \texttt{DepClean}\footnote{\href{https://github.com/castor-software/depclean}{https://github.com/castor-software/depclean}}. The tool analyses the dependencies of an artifact by creating a call graph with the libraries involved to define if a dependency is used or not; it is done through bytecode analysis.

Just as this thesis, Soto-Valero et al. focus on Java and the ecosystem of Maven Central. The paper includes a comprehensive study of the unused dependencies in the Maven ecosystem, reported that 75.1\% of the analyzed dependencies were unused dependencies. Nevertheless, the evaluation of the dependencies is still binary, but the strategy used to determine the existence of the dependency is fine-grained. This fine-grained analysis uses bytecode-analysis, just as the proof-of-concept developed in this thesis.
