% !TEX root = ..\main.tex
\chapter{Conclusion}\label{ch:Conclusion}

In this work, we have created a model for the dependencies created when using a library. The model contains three types of metrics. The first one, to measure the degree of code dependency, is the coupling metrics. We have defined coupling metrics for direct dependencies, and for transitive dependencies, considering the reachability and the propagation of the coupling. Then, we have also created coverage metrics to measure how much of a library is used, at the method and class level. Finally, the defined the usage per class metrics, to see which classes of the client are using the library and how much. We have formulated the metrics based on the criteria defined in the literature, and provided a formal definition of each metric. Moreover, we have conducted a theoretical validation of the metrics by proving the properties that the metrics should have. These properties have been obtained from the literature.

To provide an empirical validation of the metrics, we have created a proof-of-concept tool, which calculates the metric for every dependency of a given client. The tool uses libraries available in the \textit{Maven Central Repository}, which allowed us to validate the implementation by comparing the results with the literature. This comparison indicated some possible improvements, such as changing the source of the bytecode, to be able to include testing dependencies, and avoid issues with shadowed dependencies.

Furthermore, we have conducted an experiment to evaluate the significance of the coupling metrics. This experiment indicated that the current metrics are generally sufficient to indicate whether there is coupling with a dependency. Additionally, it also indicated that the usage of annotations is a special case in the context of software dependencies, which would need a specific metric to be measured.

We have also conducted a sensitivity analysis of the propagation factor used in the coupling metrics for transitive dependencies. The propagation factor is used to represent the mitigation done by the libraries between the client and the server library. The results indicated that the value of the metrics is highly sensitive to the propagation factor. In addition, we have also created a benchmark of the coupling metrics, with which to create a scale and risk evaluation of these metrics.

Finally, the proof-of-concept includes three visualizations of the model. These visualization have been validated with expert interviews. During the interviews, the experts evaluated positively the tool and its visualizations, and made some suggestions for improvement. Moreover, the actionability and clarity of the metrics in the model was also assessed during the interviews.

\section{Future work} \label{sec:future_work}
In this section, we present the future work that could be done based on the research done in this thesis. There are many other topics to be researched in the domain in software dependencies, but we focus on the model and the proof-of-concept we developed.

\subsection{The model}

The current model has had positive reactions from the professional developers interviewed during the thesis. Nevertheless, some improvements could be made. First, the coupling metrics of the model currently measure method invocation coupling and aggregation coupling. However, there are other types of connections that could be added to the set. In particular, as discovered with the significance experiment results, the first type of connection to be considered is the usage of annotations. A metric to measure the coupling created by the usage of annotations could be used in combination with the current coupling metrics for a more precise measurement of all types of dependencies. A second step to improve the coupling metrics is to improve the benchmarking. Analyzing new client libraries to extend the benchmark data and add types of clients other than libraries could help improve the quality of the benchmark and the risk evaluation of the metrics. A comparison of the results obtained from analyzing libraries and analyzing other types of software products is also possible.

In addition, during the interviews, it was suggested to create a general metric, combining the values of the current model's metrics. The general metric could give an overview of the state of the dependencies and indicate the developers which dependency needs more focused. However, the model would still contain all the other metrics to give more detailed information with the perspective of each metric.

Finally, another possibility, as explained at the begining of the thesis, is to add metrics based on dynamic analysis. Adding dynamic analysis could give more information of the actual usage of the client and the server libraries. It would allow to validate the findings of the static coupling metrics. Dynamic analysis has already been used to evaluate if a client is affected or not by a vulnerability \cite{plate2015impact}.

\subsection{The proof-of-concept}

The proof-of-concept developed for this thesis can calculate the metrics of the model for all the dependencies of the dependency tree of a given client library. The client and the server libraries have to be available in the \textit{Maven Central Repository}. The main limitation of the PoC is the process to obtain the sources of both the client and the server library. Obtaining \textit{.jar} files from Maven makes it impossible to include the tests in the analysis and adds issues with shaded dependencies within the \textit{.jar} file of the client. Therefore, an initial step would be to add the possibility of obtaining the client and server libraries from a different repository. Another option would be to change the type of analysis to source-code analysis, but this would require changing the analysis completely. Moreover, changing the way the libraries are obtained could also solve the issues with the inherited dependencies from the parent module by changing the strategy to resolve the dependency tree. Finally, since the model is meant to be language-agnostic, it would be good to look at other languages apart from Java for the implementation. It would be an interesting exercise to see which characteristics and edge cases other languages have and make both the implementation and the model more complete.
