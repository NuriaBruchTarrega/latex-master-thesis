% !TEX root = ..\main.tex
\chapter{Theoretic Model}\label{ch:TheoreticModel}

\section{Dependency evaluation model}

\subsection{Characteristics of the metrics (RQ1.1)}
% IMPORTANT: Difference between direct and indirect coupling. Detecting Indirect Coupling Yang et al. 2005
To measure the degree of dependency, we are going to define the characteristics of the coupling of the dependencies with a project. Following the criteria in the framework defined by Briand et al. \cite{briand1999unified}, we are going to define the coupling to measure. The order in which the criteria are defined, is important, since a decision in one criterion may add restrictions in the options of other criteria. Hence, we are going to define each of the criteria starting with those that the problem statement directly defines.

\paragraph{Locus of impact:}
As explained in section \ref{section:bg-coupling}, Briand et al. propose two options for the locus of impact: import and export. According to the definition of the problem, the goal of this measurement is to know how much a library depends on another. Therefore, the point of view of this evaluation is from the library that uses another one. Hence, the locus of impact of the coupling to be measured in this thesis is import. We measure the dependency from the point of view of the library that acts as a client of another library.

\paragraph{Stability of the server:}
Following the definition of stability stated by Briand et al. \cite{briand1999unified}, in this case, the server has to be stable. Briand et al. define stable classes as \textit{Classes that are not subject to change in the project at hand}. Therefore, we are going to count connections from non-stable classes to stable classes. According to the previously defined locus of impact, the non-stable classes are the clients of the stable classes.

However, in the use case of this thesis, the differentiation between stable and unstable classes is not enough. The goal is not to measure the coupling with all stable classes since these include types provided by the programming language and the standard libraries of the language. In order to answer RQ1, the coupling will only be measured with classes that are part of other open-source libraries.

\paragraph{Granularity of the measure:}
In this criterion, there are two aspects to define. The domain level of the measure, and how the metric counts the connections. First, we are going to discuss the domain level. Briand et al. define the following levels:

\begin{itemize}[noitemsep]
  \renewcommand\labelitemi{--}
  \item Attribute
  \item Method
  \item Class
  \item Set of classes
  \item System
\end{itemize}

\blankls
In this case, the goal is to measure the coupling between the set of classes of the client library and the set of classes of the server library. The measurement is done by aggregating the coupling of the smaller domains \cite{briand1999unified}.

Next, we define how the metric has to count connections. The options for counting connections defined by Briand et al. are explained in section \ref{section:bg-coupling}, in Table \ref{table:counting-connections}. The options B), D), E), and F), are not useful for this research. These options count the distinct items at the other end of the connection, not considering how many times those items are at the other end of the connection. The differences between these options are the granularity of the measure and the fact that E) considers indirect coupling.

The two other options are A) and C), which count individual connections. The difference between A and C is the domain level at which the connections are counted. The option C) counts the connections as in A), but adding up the result for each method or attribute of a class. Since the level of the domain of the metrics is not class but set of classes, a new option for counting connections is defined. The definition is created following the same style as Briand et al.: \textit{Add up the number of connections counted as in C) for each class of the set of classes}.

\paragraph{Direct and indirect coupling:}
To decide which option we want to define for this criterion, we need to distinguish two alternative scenarios in which we want to measure coupling: Direct dependencies and transitive dependencies. When measuring direct dependencies, we want to measure only direct coupling between the sets of classes, whereas for transitive dependencies it is necessary to measure indirect coupling. Hence, we will define at least two metrics: One for direct dependencies and another one for transitive dependencies.



\paragraph{Type of connection:}
With this criterion, it is defined which type of connection creates coupling between the two items, previously defined as two separate sets of classes. There are several and clearly distinguished mechanisms that can create coupling, as defined by Briand et al. \cite{briand1999unified}, listed below.

\blankls
Given class \textit{a} of set of classes \textit{A}, and class \textit{b} of set of classes \textit{B}...

\begin{enumerate}
  \item ... class \textit{a} has an attribute of type \textit{b} (Relationship of aggregation).
  \item ... method of class \textit{a} has a parameter of type \textit{b} or has return type \textit{b}.
  \item ... method of class \textit{a} has a local variable of type \textit{b}.
  \item ... method of class \textit{a} calls a method which has a parameter of type \textit{b}.
  \item ... method of class \textit{a} references attribute of class \textit{b}.
  \item ... method of class \textit{a} invokes method of class \textit{b}.
  \item ... class \textit{a} and class \textit{b} have a relationship such as uses or consists-of.
\end{enumerate}

Having one metric measure more than one of these types of connections is not recommended, for a variety of reasons. To begin with, the strengths of every type of connection have to be justified: Has one connection of type 5 the same strength as a connection of type 6? Also, when mixing types of connection there is information missing, it is not possible to know how much of the coupling is created by which connection. Therefore, all relevant types of connections in the use case of RQ1 are going to be measured by different metrics.

\unsure{I would say all of them create coupling between libraries, since all these connections mean that if the library changes, or has to be replaced, the code in which these connections take place, will have to be updated. However, it is possible that some connections are more significant or relevant than others. For example, it is likely that if a class \textit{a} has an attribute of type class \textit{b}, methods from class \textit{b} are going to be called in class \textit{a}.}


\paragraph{Inheritance:}
Within this criterion, there are three aspects to decide about: how, if at all, does the metric distinguish between inheritance-based coupling and noninheritance-based coupling? If the metric counts method invocations, does it account for polymorphism? And finally, what defines if a method is part of a class or not?

First, how does the metric treat inheritance? This question has several possible answers: Only counts inheritance, only counts non-inheritance, counts both separately, or counts both without distinction.
\unsure{I know I want to count both, but which are the implications of making it with distinction or without? Is it different if a class calls a method from a parent class from if it calls a method from a class to which it has no relationship?}

The next question is how does the metric treat polymorphism. Does it account for the methods that are overridden in descendants of the class, a call to a class creates coupling with the descendants as well?\reminder{I have a diagram to illustrate these examples and discuss about it}.

Lastly, it is necessary to define what makes a method or attribute part of a class. Is it when the method or attribute is implemented in the class, or when the method or attribute can be referenced from an instance of the class.\unsure{I would say it is when the method can be referenced from an instance of the class. Even if the method is not implemented there, if the class is updated/removed, the code that calls this method will have to be updated}.



\paragraph{Result}
All the metrics that are going to be used to measure the dependencies between libraries, are classified in Table \ref{table:metric-characteristics} according to the discussion on the criteria previously developed.

\begin{table}[h]
    \begin{center}
    \begin{tabular}{|l|l|l|l|l|l|}
    \hline
    \rot{Metric} & \rot{Types of connection} & \rot{Domain of measure} & \rot{Counting connections   } & \rot{Direct/Indirect} & \rot{Inheritance} \\ \hline
    \#1 & a & set of classes & G & Direct & both \\\hline
    \#2 & a & set of classes & G & Direct & both \\\hline
    \#3 & a & set of classes & G & Direct & both \\\hline
    \#4 & a & set of classes & G & Direct & both \\\hline
    \#5 & a & set of classes & G & Direct & both \\\hline
    \#6 & a & set of classes & G & Direct & both \\\hline
    \end{tabular}
    \end{center}
    \caption{Criteria of the set of metrics}
    \label{table:metric-characteristics}
\end{table}

\subsection{Formal definition of the metrics (RQ1.2)}

\subsubsection{Reviewing existing metrics}

\subsubsection{Defining new metrics}

\section{Dependency replacement effort}
\begin{comment}
\subsection{Defining the taxonomy of package replacement (\textbf{RQ2.2})}

Before starting the measurement of package replacement, it is important to specify which kind of replacement is being studied. Therefore, we have defined a classification of the possible scenarios.

First, Kula et al. \cite{kula2014visualizing} in their study about the visualization of the evolution of library dependency, identify four distinct behabiours. Namely, adopter, idler, updater and dropper. In addition, Kikas et al. \cite{kikas2017structure} when studying the evolution of software ecosystems, define two different types of update, explicit and implicit. Considering this two classifications, we have created the following classification:

\begin{table}[ht!]
    \begin{center}
    \begin{tabularx}{\textwidth}{|X|l|l|}
      \hline
      Description & Kula et al. & Kikas et al. \\
      \hline\hline
      Add new package dependency & adopter & - \\
      \hline
      Maintain package dependency in new application version & idler & - \\
      \hline
      Manual update of dependent package version & updater & explicit package update \\
      \hline
      Automatic update of dependent package version & updater & implicit package update \\
      \hline
      Change a dependency from one package to another & dropper \& adopter & - \\
      \hline
      Remove dependency with a package & dropper & - \\
      \hline
    \end{tabularx}
    \end{center}
    \caption{Taxonomy of depdendency evolution}
    \label{table:taxonomy-dependency}
\end{table}

\blankls
In this classification, we have added the scenario in which a dependency is dropped and substituted by another one. When looking at the terminology defined by Kula et al. it would mean dropping a package, and adopting a new one at the same time. This situation could be given due to libraries that are not maintained longer. These libraries, are usually marked as deprecated, indicating that there is no team updating it anymore. The dependencies created with these libraries, are called halted libraries \cite{pashchenko2018vulnerable}.

Vulneriabilities created by halted dependencies have to be mitigated with a different and more costly strategy. There are different options to mitigate the vulnerabilities, listed below:

\begin{itemize}
  \item Replace with a library with the same API. Therefore, the replacement would only involve changing the name of the library in the calls to it.

  \item Replace with a library in which the API is different, with different parameters needed for the calls. In this case, the replacement would involve the entire methods (units) in which the library is used.

  \item Creating a new library. The replacement of this library with this option involves developing the functionalities that were used from the original library.

  \item Contribute to the library. In this case, the effort would be related to the amount of code that needs to be changed in order to fix the bug that is causing the vulnerability.
\end{itemize}
\end{comment}
