% !TEX root = ../main.tex
\chapter{Dependency evaluation model}\label{ch:TheoreticModel}

\section{Measuring the degree of dependency}\label{sect:degree-dependency}
\subsection{Definition of coupling}\label{subsect:defCoupling}
% IMPORTANT: Difference between direct and indirect coupling. Detecting Indirect Coupling Yang et al. 2005
To measure the degree of dependency, we are going to define the characteristics of the coupling of the dependencies with a project. Following the six criteria in the framework defined by Briand et al. \cite{briand1999unified}, described in Section \ref{section:bg-coupling}, we are going to define the coupling to measure.

\paragraph{Criterion 1 - Type of connection:}
With this criterion, it is defined which type of connection creates coupling between the two items, previously defined as two separate sets of classes. There are several and clearly distinguished mechanisms that can create coupling, as defined by Briand et al. \cite{briand1999unified}, listed below.

\blankls
Given class \textit{a} of library \textit{A}, and class \textit{b} of library \textit{B}...

\begin{enumerate}
  \item ... class \textit{a} has an attribute of type \textit{b} (Relationship of aggregation).
  \item ... method of class \textit{a} has a parameter of type \textit{b} or has return type \textit{b}.
  \item ... method of class \textit{a} has a local variable of type \textit{b}.
  \item ... method of class \textit{a} calls a method which has a parameter of type \textit{b}.
  \item ... method of class \textit{a} references attribute of class \textit{b}.
  \item ... method of class \textit{a} invokes method of class \textit{b}.
  \item ... class \textit{a} and class \textit{b} have a relationship such as uses or consists-of.
\end{enumerate}

Having one metric measure more than one of these types of connections is not recommended, for a variety of reasons. To begin with, the strengths of every type of connection have to be justified: Has one connection of type 5 the same strength as a connection of type 6? Also, when mixing types of connection there is information missing, it is not possible to know how much of the coupling is created by which connection. Therefore, all relevant types of connections in the use case of RQ1 are going to be measured by different metrics.

To decide which types of connections to measure, %since all of them create coupling between libraries,
we have decided to review the literature on coupling metrics, to understand which connections are the most measured and why.

\begin{table}[ht!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
         \hline
         Reference                      & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\hline
         \cite{eder1994coupling}        & x & x & x & x &   & x & x \\\hline
         \cite{hitz1995measuring}       & x & x & x &   & x & x & x \\\hline
         \cite{briand1997investigation} & x & x &   &   &   & x &   \\\hline
         \cite{wilkie2000coupling}      & x & x &   &   &   &   &   \\\hline
         \cite{yang2005detecting}       & x & x & x & x &   & x &   \\\hline
         \cite{gui2007ranking}          & x &   &   &   & x & x &   \\\hline
         \cite{gupta2009package}        & x & x & x & x & x & x & x \\\hline
         \cite{harrison1998coupling}    &   &   &   &   & x & x &   \\\hline
         \cite{du2004refactoring}       & x &   &   &   & x & x &   \\\hline
         \cite{koetter2019assessing}    & x &   &   &   & x & x &   \\\hline
    \end{tabular}
    \caption{Literature usage of the types of connection}
    \label{tab:type-con-literature}
\end{table}

 Types 1 and 6 are the most used in the literature and, in particular, method invocation coupling is
hypothesized to be the most relevant one \cite{briand1999unified}, therefore we define a metric to measure \textbf{type 6: method invocation}.

The second metric that we consider is \textbf{type 1: aggregation coupling}, for two main reasons. It is used as type 6 in the reviewed literature, and because in some cases, measuring method invocations may not be enough to understand how much maintenance a library dependency may need. There is the possibility that a class has an attribute of another class, but never calls a method that belongs to that class.

The above-mentioned metrics are those that we consider in our work, and we will explain them in greater detail in Section~\ref{section:defMetrics}. Nevertheless, it might be necessary to include additional metrics in the future, to account for other connection types.

\paragraph{Criterion 2 - Locus of impact:}
As explained in section \ref{section:bg-coupling}, Briand et al. \cite{briand1999unified} propose two options for the locus of impact: import and export. According to the definition of the problem, the goal of this measurement is to know how much a library depends on another. Therefore, the point of view of this evaluation is from the library that uses another one. Hence, the locus of impact of the coupling to be measured in this thesis is \textbf{import}. We measure the dependency from the point of view of the library that acts as a client of a server library.

\paragraph{Criterion 3 - Granularity of the measure:}
In this criterion, there are two aspects to define. (1) The aggregation level of the measure, and (2) how the metric counts the connections. First, we are going to discuss the domain level. Briand et al. \cite{briand1999unified} define the following levels:

\begin{itemize}[noitemsep]
  \renewcommand\labelitemi{--}
  \item Attribute
  \item Method
  \item Class
  \item Set of classes
  \item System
\end{itemize}

\blankls
The goal is to measure the coupling between the set of classes of the client library and the classes of the server library. The measurement is done by aggregating the coupling of the more fine-grained levels \cite{briand1999unified}. For consistency, we name this aggregation level \textbf{library level}.

Next, we define how the metric has to count connections. The options for counting connections defined by Briand et al. \cite{briand1999unified} are explained in Table \ref{table:counting-connections}. The options B), D), E), and F), are not useful for this research. These options count the distinct items at the other end of the connection, not considering how many times those items are at the other end of the connection.

The two other options are A) and C), which count individual connections. The difference between A and C is the aggregation level at which the connections are counted. The option C) counts the connections as in A), but adding up the result for each method or attribute of a class. Since the level of the domain of the metrics is not class but set of classes, a new option for counting connections is defined. The definition is created following the same style as Briand et al.: \textbf{Add up the number of connections counted as in C) for each class of the set of classes}. By following this method of aggregating the number of connections through aggregation levels, a fine-grained analysis is maintained for the aggregation level of the metrics.

\paragraph{Criterion 4 - Stability of the server:}
Briand et al. define stable classes as \textit{"Classes that are not subject to change in the project at hand"} \cite{briand1999unified}. Following this definition, the server has to be stable in our case. Therefore, we are going to count connections from non-stable classes to \textbf{stable classes}. According to the previously defined locus of impact, the non-stable classes are the clients of the stable classes.

However, in this thesis, the differentiation between stable and unstable classes is not enough. The goal is to measure coupling only with classes that are part of other open-source libraries. Therefore, the classes that belong to standard libraries and the programming language types, although being stable classes, will not be considered by the metrics.

\paragraph{Criterion 5 - Direct and indirect coupling:}
To decide which option we want to define for this criterion, we need to distinguish two alternative scenarios in which we want to measure coupling: Direct dependencies and transitive dependencies. When measuring direct dependencies, we want to measure only direct coupling between the libraries, whereas for transitive dependencies it is necessary to measure indirect coupling. Hence, \textbf{both types of coupling} will be measured, with two different metrics for each selected type of connection: One for direct dependencies and another one for transitive dependencies.

\paragraph{Criterion 6 - Inheritance:}
Within this criterion, there are three aspects to decide about: how, if at all, does the metric distinguish between inheritance-based coupling and noninheritance-based coupling? If the metric counts method invocations, does it account for polymorphism? And finally, what defines if a method is part of a class or not?

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{figures/specialcases.png}
\caption{Example of coupling special cases, based on example from Briand et al. \cite{briand1999unified}}
\label{fig:specialcases}
\end{center}
\end{figure}

In order to answer the first question, we focus on the method \texttt{mc} of \texttt{ClassB} in Figure \ref{fig:specialcases}. This method invokes \texttt{ma} of \texttt{ClassA}, inherited by \texttt{ClassB}.

This is known as \textit{inheritance-based} coupling and is sometimes considered as a special case of coupling.
When there is a change of an inherited method that a class uses, it  requires the same maintenance as the method that is not inherited. Therefore, our metrics  \textbf{include inheritance-based coupling without distinction}.

% Next, we discuss about whether to account for polymorphism.
In the case of the second question, polymorphism, we look at the methods of \texttt{ClassA}. This class contains an attribute of type \texttt{Class1}, which considering dynamic assignation of types could also be of type \texttt{Class2} or \texttt{Class3}.
%In this case,
We first analyze whether a call to a method of \texttt{Class1} would create coupling with \texttt{Class2} and \texttt{Class3}, and if it makes a difference when the method is overridden or not. The method \texttt{ma} invokes \texttt{m1}, which is not overridden by any of the descendants of \texttt{Class1}. When a change is made in \texttt{Class2} or \texttt{Class3} no change is required as the invoked method remains the same. In contrast, method \texttt{mb} calls \texttt{m2}, which is overridden in \texttt{Class2}. Here, the implementation of \texttt{m2} in \texttt{Class2} could be updated, and this may affect the way \texttt{ClassA} uses it, and therefore changes may be needed. Thus, it is necessary to \textbf{account for polymorphism}.

Lastly, we discuss about how to decide whether a method belongs to a class or not. We have two options: (1) a method belongs to the class that implements it (could be more than one since we account for polymorphism), or (2) a method belongs to the class that it is referenced from. An example of this can be found in the last two lines of the method \texttt{mc} of \texttt{ClassB} call method \texttt{m1} and \texttt{m2} on an object of type \texttt{Class2}. The difference is that \texttt{m1} is implemented in \texttt{Class1} and \texttt{m2} is overridden in \texttt{Class2}. From a maintenance perspective, when the method \texttt{m1} is updated in \texttt{Class1}, this probably requires update in \texttt{ClassB} as well. However, changes in \texttt{Class2} will not generate a need to update the method call in \texttt{ClassB}. When  \texttt{m2} is updated in \texttt{Class1}, it will not make a difference for this call to \texttt{m2} since it is not executing the implementation of \texttt{Class1}. Therefore, \textbf{a method call creates coupling with the class that contains the implementation}.

\paragraph{Result}
All the metrics that are going to be used to measure the dependencies between libraries, are classified in Table \ref{table:metric-characteristics} according to the previous discussion on the criteria.

\begin{table}[h]
    \begin{center}
    \begin{tabular}{|l|l|l|l|l|l|l|l|l|}
    \hline
    \rot{Metric} & \rot{Type of connection} & \rot{Locus of impact} & \rot{Domain of measure} & \rot{Counting connections   } & \rot{Direct/Indirect} & \rot{Inheritance} & \rot{Polymorphism} & \rot{Item belongs to class} \\ \hline
    \hline
    \#1   & 6 & Import & Library & G & Direct   & Both, no distinction & Yes & Implemented \\\hline
    \#2   & 1 & Import & Library & G & Direct   & Both, no distinction & Yes & Implemented \\\hline
    \hline
    \#3   & 6 & Import & Library & G & Indirect & Both, no distinction & Yes & Implemented \\\hline
    \#4   & 1 & Import & Library & G & Indirect & Both, no distinction & Yes & Implemented \\\hline
    \end{tabular}
    \end{center}
    \caption{Criteria of the set of metrics}
    \label{table:metric-characteristics}
\end{table}

\subsection{Metrics for direct dependencies}\label{section:defMetrics}
In this section, there is the formulation of the formal definition of the metrics. However, before the definitions, there is a brief discussion in which the definition of coupling of the proposed metrics are compared with the existing metrics in the literature described in Section \ref{section:bg-coupling}. To end the section, the theoretical validation of the metrics is done by proving the five properties of coupling metrics.

\subsubsection{Revisiting existing metrics}
Once we have defined the coupling that is going to be measured by each of the metrics (see Table \ref{table:metric-characteristics}), we can compare it with the existing coupling metrics, according to Table \ref{table:coupling-metrics} in Section \ref{section:bg-coupling}.

\paragraph{Metric \#1}
To compare the coupling defined for this first metric defined in Table \ref{table:metric-characteristics} with the existing metrics, we focus on the ones that have the following characteristics:

\begin{itemize}
  \item Type of connection: method invocations (type 6 in Table \ref{table:types-connections})
  \item Locus of impact: import
  \item Direct or indirect coupling: direct
  \item Counting connections: count individual connections (option A or C in Table \ref{table:counting-connections}).
\end{itemize}

The metrics that share these characteristics are \textit{MPC}, the group \textit{ICP}, and the metrics \textit{AMMIC}, \textit{IFMMIC} and \textit{OMMIC}. However, \textit{MPC} does not consider polymorphic implementations of the called methods. \textit{IFMMIC} is a metric formulated specifically for C++ \cite{briand1997investigation} and therefore is not useful for our model.

From the group of metrics \textit{ICP}, the metric \textit{ICP}  considers both inheritance and non-inheritance coupling and therefore shares the definition of coupling with our metric. Nevertheless, according to the definition of \textit{ICP}, the coupling created by each method call is weighted by the number of parameters of the called method. In this aspect, it differs from metric \#1.

Finally, the metrics \textit{AMMIC} and \textit{OMMIC} use the same definition of coupling as metric \#1 except that \textit{AMMIC} counts the method invocations to ancestors and \textit{OMMIC} to other classes. Therefore, metric \#1 is the sum of \textit{AMMIC} and \textit{OMMIC} but aggregated to the library aggregation level instead of class level.

\paragraph{Metric \#2}
In the case of the second metric as defined in Table \ref{table:metric-characteristics}, we focus on the metrics with the following characteristics:

\begin{itemize}
  \item Type of connection: client class contains an attribute of type server class, aggregation coupling (type 1 in Table \ref{table:types-connections})
  \item Locus of impact: import
  \item Direct or indirect coupling: direct
  \item Counting connections: count individual connections (option A or C in Table \ref{table:counting-connections})
\end{itemize}

According to Table \ref{table:coupling-metrics}, the metrics that share these characteristics are \textit{DAC}, and from the suite of metrics by Briand et al. \cite{briand1997investigation} the metrics \textit{IFCAIC}, \textit{ACAIC} and \textit{OCAIC}. However, \textit{IFCAIC} is an extension for C++ and will not be considered.

According to the definition of \textit{DAC}, it counts the number of attributes of a class that have any other class as type. Therefore, instead of calculating the coupling between two classes, it calculates the coupling of a class with every other class. However, metric \#2 is used at the library level, and to calculate coupling between two libraries instead of the coupling of one library with all the others.

Finally, \textit{ACAIC} and \textit{OCAIC} consider aggregation coupling with ancestors and others respectively. Therefore, metric  \#2 is the sum of these two metrics, but aggregated to library aggregation level, since the metrics are designed for class level.

\subsubsection{Formal definition}\label{subsec:metric-definition}

\paragraph{Metric \#1: Direct method invocation coupling (\texttt{MIC})}
The $\verb|MIC|$ metric measures the dependency between two libraries, one acting as client ($L_c$) and the other as server ($L_s$).
Based on the granularity of the measure criterion discussed in Section~\ref{subsect:defCoupling}, this metric is calculated for each of the classes implemented in $L_c$, and for each of the methods implemented $\verb|M|(L_c)$ in these classes. For each implemented method  $m_c \in \verb|M|(L_c)$, we count the number of individual invocations to a method of $L_s$, denoted $\verb|nII|(m_c,L_s)$. For each method invocation made by the methods implemented in $L_c$, we count only the ones that are implemented in stable classes (not implemented in $L_c$). The set of stable methods invoked is denoted $\verb|SIM|(m_c)$.

\begin{equation}
\label{eqn:mic}
\verb|MIC|(L_c, L_s) =\!\!\!\!\! \sum_{m_c \in \verb|M|(L_c)} \verb|nII|(m_c, L_s)
\end{equation}

According to the criterion inheritance, it is necessary to take into account all the polymorphic implementations of the invoked method that are implemented in $L_s$. Therefore, we intersect the set of polymorphic implementations of an invoked method $\verb|PM|(m_s)$ with the set of methods $\verb|M|(L_s)$ implemented in $L_s$. Finally, to obtain the number of individual invocations, $\verb|nII|(m_c,L_s)$, we multiply the number of times a stable method ($m_s \in \verb|SIM|(m_c)$) has been invoked, $\verb|nI|(m_c, m_s)$ by the number of polymorphic implementations $\verb|nP|(m_s, L_s)$ of the method in $L_s$.

\begin{equation}
\label{eqn:mic-nii}
   \verb|nII|(m_c, L_s) = \sum_{m_s \in \verb|SIM|(m_c)} \verb|nI|(m_c, m_s)*\verb|nP|(m_s, L_s)
\end{equation}

\begin{equation}
\label{eqn:mic-np}
    \verb|nP|(m_s, L_s) = |\verb|PM|(m_s) \cap \verb|M|(L_s)|
\end{equation}

\paragraph{Metric \#2: Direct aggregation coupling (\texttt{AC})}

The $\verb|AC|$ metric counts the number of times when a class of $L_c$ has an attribute whose type is a class implemented in $L_s$. Therefore, the metric is calculated for each class implemented in $L_c$ ($\verb|C|(L_c)$). For each class, we consider only those attributes types that are stable classes (not implemented in $L_c$). The set of stable attribute types in a class $c$ is $\verb|SAT|(c_c)$.

To account for polymorphism (criterion \textit{inheritance}), we count all the descendants of the class that are implemented in $L_s$. Therefore, we intersect the set of the class descendants, $\verb|DC|(c_s)$, with the set of
classes implemented in $L_s$ ($\verb|C|(L_s)$). Finally, to count the  individual connections, we multiply the number of times a client class $c_c$ has an attribute of type the server class $c_s$ $\verb|NA|(c_c, c_s)$ by the number of class descendants (class included) implemented in $L_s$ ($\verb|nDC|(c_s,L_s)$).

\begin{equation}
\label{eqn:ac}
  \verb|AC|(L_c,L_s) = \!\!\!\!\sum_{c_c \in \verb|C|(L_c)} \sum_{c_s \in \verb|SAT|(c_c)} \!\!\!\!\verb|NA|(c_c, c_s)*\verb|nDC|(c_s, L_s)
\end{equation}

\begin{equation}
\label{eqn:ac-ndc}
    \verb|nDC|(c_s, L_s) = |\verb|DC|(c_s) \cap \verb|C|(L_s)|
\end{equation}

\subsubsection{Theoretical validation}
\unsure{Should I move the description of the properties to background, or is it fine here?}
The theoretical validation of the metrics consists of demonstrating the properties of the metrics. The theoretical validation is necessary since it proves that the metrics share some properties with the attribute these are measuring, in this case coupling. In particular, for coupling metrics there are five properties defined by Briand et al. \cite{briand1996property} which have been largely used by the literature \cite{poshyvanyk2006conceptual, allen1999measuring, zhao2004measuring}.

For the description of the properties, we use $\verb|Coupling|(L_c, L_s)$ to refer to both $\verb|AC|$ and $\verb|MIC|$, and $\verb|R|(L_c, L_s)$ to refer to the set of relationships between $L_c$ and $L_s$. $\verb|Coupling|(L_c, L_s)$ uses $\verb|R|(L_c, L_s)$ to evaluate the coupling between the two elements, but the way it is used differs per metric. The description of the properties is based on the description done by Briand et al. \cite{briand1996property} which was meant for coupling metrics that measure the coupling within an element, or between an element and all the other elements. Therefore, the description has been adapted for metrics that measure coupling between two different elements. In addition, since all the defined metrics measure import coupling, the definitions of the properties are focused on import coupling.

\paragraph{Property 1: Nonnegativity}

Let $L_c$ be a client library and $L_s$ be a server library. The coupling between the two libraries is non-negative. $\verb|Coupling|(L_c, L_s) \ge 0$

\paragraph{Property 2: Null value}
Coupling is expected to be null (zero) when there is not a single import relationship between the client and the server libraries.

Let $L_c$ be a client library and $L_s$ be a server library. The coupling between the two libraries is null if the set of import relationships from $L_c$ to $L_s$, $\verb|R|(L_c, L_s)$, is empty. Therefore, $\verb|R|(L_c, L_s) = \emptyset \implies \verb|Coupling|(L_c, L_s) = 0$.

\paragraph{Property 3: Monotonicity}
Considering the definition of coupling, it is expected that when more relationships are added between the libraries, coupling does not decrease.

Let $L_c$ be a client library, $L_s$ be a server library, and $c \in L_c$ be a class in $L_c$. If we modify class $c$ to form a new class $c'$ which is identical to $c$ except that $\verb|R|(c, L_s) \subseteq \verb|R|(c', L_s)$. For example, some method invocations have been added from $c$ to classes implemented in $L_s$. Let $L_c'$ be a library identical to $L_c$ but in which $c$ has been replaced by $c'$. Then, $\verb|Coupling|(L_c, L_s) \le \verb|Coupling|(L_c', L_s)$.

\paragraph{Property 4: Merging of classes}
The original definition of the property is created for metrics that measure coupling within a system, and therefore it is necessary to reformulate it. It is expected that if two classes of a system are merged, the coupling of the system does not increase. If two classes are merged, the coupling between the two classes is subtracted from the total coupling of the system.

When considering the coupling between a client library and a server library, if two classes of the client library are merged, the coupling between the two libraries would not increase. It could decrease, dependending on how the refactoring is performed. If the classes share usage of the server library, it is possible that one of the usages is removed.

Therefore, let $L_c$ be a client library, $L_s$ be a server library, and $c_1, c_2 \in L_c$ two classes from $L_c$. Let $c'$ be the class that results when merging  $c_1$ and $c_2$, and $L_c'$ be the library resulting from $L_c$ when $c_1$ and $c_2$ have been replaced by $c'$. Then, $\verb|Coupling|(c_1, L_s) + \verb|Coupling|(c_2, L_s) \ge \verb|Coupling|(c', L_s)$ and $\verb|Coupling|(C, L_s) \ge \verb|Coupling|(C', L_s)$.

\paragraph{Property 5: Merging of unconnected classes}
This property is a variation of the previous one, and it has to be adapted to the use case of this thesis as well. It is expected that the coupling of the system will stay the same if two classes of a system, which have no relationship, are merged. Since the class that results of the merging will have the same number of relationships with other classes as the original two.

When measuring the coupling between a client library and a server library, the two unconnected classes are not using the server library in the same way. Therefore, none of the relationships with the server library can be merged when merging the two classes, and the coupling with the server library stays the same.

Let $L_c$ be a client library and $c_1, c_2 \in L_c$ two classes from $L_c$. Let $c'$ be the class that is the union of  $c_1$ and $c_2$, and $L_c'$ be the library identical to $L_c$ but in which $c_1$ and $c_2$ have been replaced by $c'$. If there are no relationships between $c_1$ and $c_2$, then, $\verb|Coupling|(c_1) + \verb|Coupling|(c_2) \ge \verb|Coupling|(c')$ and $\verb|Coupling|(C) \ge \verb|Coupling|(C')$.

\subsubsection{Theoretical validation: MIC}

\paragraph{Property 1: Nonnegativity}
If we assume that the metric $\verb|MIC|$ does not fulfill the property Nonnegativity, there should be a client library $L_s$ and a server library $L_c$ such that $\verb|MIC|(L_c, L_s) < 0$.
According to the equation \ref{eqn:mic}, this means that exists at least one client method $m_c \in \verb|M|(L_c)$ such that $\verb|nII|(m_c, L_c) < 0$. Follow the equation of $\verb|nII|$ \ref{eqn:mic-nii}, this opens two possibilities.

First, that there is a server method $m_s \in \verb|SIM|(m_c)$ such that $\verb|nI|(m_c, m_s) < 0$. However, $m_s$ is a method out of the set $\verb|SIM|(m_c)$ which is the set of stable methods invoked by $m_c$, which means that $\verb|nI|(m_c, m_s) > 0$ for all $m_s \in \verb|SIM|(m_c)$, therefore it is a contradiction.

The other option is that there is a method $m_s \in \verb|SIM|(m_c)$ such that $\verb|nP|(m_s, L_s) < 0$. $\verb|nP|(m_s, L_s)$, according to the equation \ref{eqn:mic-np}, corresponds to the cardinality of the intersection between the set $\verb|PM|(m_s)$ and $\verb|M|(L_s)$. Therefore, the cardinality of the intersection has to be less than zero. However, the cardinality of the intersection is by definition greater or equal to zero. This constitutes a contradiction.

Therefore, the initial assumption is not true, and \textit{Nonnegativity} holds for the metric $\verb|MIC|$.

\paragraph{Property 2: Null value}
Assuming there is no null value for metric $\verb|MIC|$, there is a client library $L_c$ and a server library $L_s$ such that $\verb|R|(L_c, L_s) = \emptyset$, and $\verb|MIC|(L_c, L_s)	\neq 0$. As non-negativity holds, we have that $\verb|MIC|(L_c, L_s) \ge 0$. Therefore, $\verb|MIC|(L_c, L_s) > 0$. Hence, following equation \ref{eqn:mic} there is a client method $m_c \in M(L_c)$ such that $\verb|nII|(m_c, L_s) > 0$.

Thus, according to equation \ref{eqn:mic-nii}, there is a server method $m_s \in \verb|SIM|(m_c)$, such that $\verb|nI|(m_c, m_s) > 0$ and $\verb|nP|(m_s, L_s) > 0$. Therefore, the method $m_s$ is called at least one time by the method $m_c$ from the client library $L_c$, and at the same time is implemented by the server library $L_s$, which means that there is a relationship between $L_c$ and $L_s$, which contradicts the original assumption that $\verb|R|(L_c, L_s) = 0$.

Consequently, there is a \textit{null value} for metric $\verb|MIC|$.

\paragraph{Property 3: Monotonicity}
Let $L_c$ be a client library that contains class $c_c$, and let $c_c'$ be a class resulting from adding relationships with the server library $L_s$ to the class $c_c$. Then, $\verb|R|(c_c, L_s) \subseteq \verb|R|(c_c', L_s)$. Let $L_c'$ be a client library identical to $L_c$ but in which the class $c_c$ has been replaced by $c_c'$. Therefore, $\verb|R|(L_c, L_s) \subseteq \verb|R|(L_c', L_s)$.

Let's assume that the $\verb|MIC|$ metric does not fulfill the property monotonicity, this would mean that $\verb|MIC|(L_c, L_s) > \verb|MIC|(L_c', L_s)$. Since the only difference between $L_c$ and $L_c'$ is the substitution of $c_c$ by $c_c'$, then $\sum_{m_c \in \verb|M|(c_c)} \verb|nII|(m_c, L_s) > \sum_{m_c' \in \verb|M|(c_c')} \verb|nII|(m_c', L_s)$ (see equation \ref{eqn:mic}). Therefore, the methods of class $c_c$ have more individual invocations to $L_s$ than the methods from class $c_c'$. This contradicts the initial assumption that $\verb|R|(c_c, L_s) \subseteq \verb|R|(c_c', L_s)$.

Therefore, \textit{Monotonicity} holds for the metric $\verb|MIC|$.

\paragraph{Property 4: Merging of classes}
Let $L_c$ be a client library that includes the classes $c_1$ and $c_2$. Let $c'$ be a class such that $c_1 + c_2 = c'$ and $L_c'$ be a client library identical to $L_c$ but where $c_1$ and $c_2$ have been replaced by $c'$. If we assume that the property merging of classes does not hold for metric $\verb|MIC|$, it would mean that $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$ and at the same time $\verb|MIC|(L_c, L_s) > \verb|MIC|(L_c', L_s)$.

Therefore, there is a method $m_c$ which is implemented in $c_1$ or $c_2$ such that contains a call to a method $m_s$ which does not exist in any of the methods implemented in $c'$. This is a contradition with the initial affirmation $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$. Therefore, the property \textit{Merging of classes} holds for metric $\verb|MIC|$.

\paragraph{Property 5: Merging of unconnected classes}
Let $L_c$ be a client library and $L_s$ be a server library. Let $c_1$ and $c_2$ be classes implemented in $L_c$, such that $\verb|R|(c_1, L_s) \cap \verb|R|(c_2, L_s) = \emptyset$. Let $c'$ be a class such that $c_1 + c_2 = c'$. Therefore, $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$. Let $L_c'$ be a client library identical to $L_c$ but in which $c_1$ and $c_2$ have been replaced by $c'$. We assume that the metric $\verb|MIC|$ does not fulfill this property.

Therefore, $\verb|MIC|(L_c, L_s) \neq \verb|MIC|(L_c', L_s)$. According to property \textit{Merging of classes}, $\verb|MIC|(L_c, L_s)$ cannot be less than $\verb|MIC|(L_c', L_s)$. Thus, $\verb|MIC|(L_c, L_s) > \verb|MIC|(L_c', L_s)$. This means that there is a $m_c$ implemented in $c_1$ or $c_2$ that contains an invocation to a method $m_s$ implemented in $L_s$, which is not included in $c'$. This contradicts that $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$.

Therefore, property \textit{Merging of unconnected classes} holds for metric $\verb|MIC|$.

\subsubsection{Theoretical validation: AC}

\paragraph{Property 1: Nonnegativity}
Supose that the metric $\verb|AC|$ does not have the nonnegativity property. Thus, there is a client library $L_c$ and a server library $L_s$ such that $\verb|AC|(L_c, L_s) < 0$. Then, according to equation \ref{eqn:ac} there is a client class $c_c \in \verb|C|(L_c)$ and a server class $c_s \in \verb|SAT|(c_c)$ such that either $\verb|NA|(c_c, c_s)$ or $\verb|nDC|(c_s, L_s)$ have a negative value.

Let's assume that $\verb|NA|(c_c, c_s) < 0$. This means that the $c_s$ is a class that is included in the set of stable classes declared as fields in $c_c$ ($c_s \in \verb|SAT|(c_c)$) and, at the same time is declared a negative number of times, which is a contradiction.

Therefore, $\verb|nDC|(c_s, L_s)$ has to be negative. According to equation \ref{eqn:ac-ndc}, $\verb|nDC|(c_s, L_s)$ corresponds to the cardinality of the intersection between two sets. Even if the two sets do not share any element, by definition the intersection will be the empty set, and the cardinality will be zero. Hence, $\verb|nDC|(c_s, L_s)$ cannot have a negative value, and the initial assumption is false.

In conclusion, \textit{Nonnegativity} holds for the metric $\verb|AC|$.

\paragraph{Property 2: Null value}
If we assume that property null value does not hold for metric $\verb|AC|$, there has to be a client library $L_c$ and a server library $L_s$ such that have no relationship ($\verb|R|(L_c, L_s) = 0$) and $\verb|AC|(L_c, L_s)	\neq 0$. Since $\verb|AC|$ has the property \textit{Nonnegativity}, the result cannot be negative, which means that $\verb|AC|(L_c, L_s) > 0$. Hence, following equation \ref{eqn:ac}, there is a client class $c_c \in \verb|C|(L_c)$ and a server class $c_s \in \verb|SAT|(c_c)$ such that $\verb|NA|(c_c, c_s) > 0$ and $\verb|nDC|(c_s, L_s) > 0$. This means that the class $c_s$ is at the same time declared at least once by the client class $c_c$ ($\verb|NA|(c_c, c_s) > 0$) and is implemented in the server library $L_s$. However, this would create a relationship between $L_c$ and $L_s$, which contradicts the original assumption.

 Therefore, the property \textit{Null value} holds for metric $\verb|AC|$.

\paragraph{Property 3: Monotonicity}
Let $L_c$ be a client library that contains class $c_c$, and let $c_c'$ be a class identical to $c_c$ but more relationships with the server library $L_s$. Then, $\verb|R|(c_c, L_s) \subseteq \verb|R|(c_c', L_s)$. Let $L_c'$ be a client library identical to $L_c$ but in which the class $c_c$ has been replaced by $c_c'$. Therefore, $\verb|R|(L_c, L_s) \subseteq \verb|R|(L_c', L_s)$.

If we assume that the metric $\verb|AC|$ does not fulfill this property, means that $\verb|AC|(L_c, L_s) > \verb|AC|(L_c', L_s)$. The only difference between these two calculations is the result of the calculation for $c_c$ and $c_c'$. Therefore, $\sum_{c_s \in \verb|SAT|(c_c)} \verb|NA|(c_c, c_s) * \verb|nDC|(c_s, L_s) > \sum_{c_s \in \verb|SAT|(c_c')} \verb|NA|(c_c', c_s) * \verb|nDC|(c_s, L_s)$, see equation \ref{eqn:ac}.

This means that there is a server class $c_s \in \verb|SAT|(c_c)$, that is implemented in $L_s$ ($\verb|nDC|(c_s, L_s) > 0$) such that $\verb|NA|(c_c, c_s) > \verb|NA|(c_c', c_s)$. This contradicts the original assumption that $c_c'$ is constructed from $c_c$ but with additional relationships with $L_s$. $\verb|NA|(c_c, c_s)$ will only be greater than $\verb|NA|(c_c', c_s)$ if there is an attribute of type $c_s$ in $c_c$ (which is a relationship between $c_c$ and $L_s$) that does not exist in $c_c'$.

Therefore, \textit{Monotonicity} holds for the metric $\verb|AC|$.

\paragraph{Property 4: Merging of classes}
Let $L_c$ be a client library that includes the classes $c_1$ and $c_2$. Let $c'$ be a class such that $c_1 + c_2 = c'$ and $L_c'$ be a client library identical to $L_c$ but where $c_1$ and $c_2$ have been replaced by $c'$. We assume that the property merging of classes does not hold for metric $\verb|AC|$,. Therefore, $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$ and, also $\verb|AC|(L_c, L_s) > \verb|AC|(L_c', L_s)$.

Thus, either $c_1$ or $c_2$ contain an attribute of type $c_s$, such that $c_s$ is implemented in $L_s$ and it is not included $c'$. This creates a contradition with the initial affirmation $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$, since the declaration of an attribute of type $c_s$ is included in $\verb|R|(c_1, L_s)$ or $\verb|R|(c_2, L_s)$. Therefore, \textit{Merging of classes} holds for metric $\verb|AC|$.

\paragraph{Property 5: Merging of unconnected classes}
Let $L_c$ be a client library and $L_s$ be a server library. Let $c_1$ and $c_2$ be classes implemented in $L_c$, such that $\verb|R|(c_1, L_s) \cap \verb|R|(c_2, L_s) = \emptyset$. Let $c'$ be a class such that $c_1 + c_2 = c'$. Therefore, $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$. Let $L_c'$ be a client library identical to $L_c$ but in which $c_1$ and $c_2$ have been replaced by $c'$. We assume that the metric $\verb|AC|$ does not fulfill property \textit{Merging of unconnected classes}.

Therefore, $\verb|AC|(L_c, L_s) \neq \verb|AC|(L_c', L_s)$. According to property \textit{Merging of classes}, it cannot happen that $\verb|AC|(L_c, L_s) < \verb|AC|(L_c', L_s)$. Therefore, $\verb|AC|(L_c, L_s) > \verb|AC|(L_c', L_s)$. The only way this is if there is an attribute of type $c_s$ declared in $c_1$ or $c_2$ and implemented in $L_s$, such that is not included in $c'$. This creates a contradition with the initial affirmation that $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$.

Therefore, metric $\verb|AC|$ fulfills \textit{Merging of unconnected classes}.

\subsection{Metrics for transitive dependencies}\label{subsect:defMetricsTransitive}
In this section, the metrics to measure transtive dependencies will be described. First, the characteristics of the metrics, according to the criteria previously discussed and summarized in Table \ref{table:metric-characteristics}, are compared to the exisiting metrics described in section \ref{section:bg-coupling}. Next, some concepts involved in the formulation of the transitive metrics are explained. Then, there is a formal definition of the two metrics for transitive dependencies. Finally, the five properties of coupling metrics are demonstrated for the two metrics.

\subsubsection{Revisiting existing metrics}
In the set of metrics reviewed by Briand et al. \cite{briand1999unified} there is only one metric that does count indirect coupling, $RFC'$ (see Table \ref{table:coupling-metrics}). This metric also counts inheritance-based coupling and it is focused on the client element, just as the metrics \#3 and \#4 defined in Table \ref{table:metric-characteristics}. However, $RFC'$ is calculated at the class aggregation level, whereas the metric for this work are calculated at the library level. Furthermore, the strategy to count connections is E, which means that it counts the number of elements with which the class has a connection, not how many connections.

Therefore, both metrics \#3 and \#4 are going to be different from those reviewed by Briand et al. \cite{briand1999unified}.

\subsubsection{Concepts related to transitive dependencies}\improvement{should this go in background instead?}
In order to define the coupling for transitive metrics, other factors have to be taken into account which are not needed for the direct metrics.

\paragraph{Reachability}
To measure the transitive dependencies, only those methods or classes of the transitive dependencies that are \textit{reachable} from the analysed client library. For a given call-graph, a method is reachable if there is a path from the client library to the method. For example, in Figure \ref{fig:reachability}, there is no path from \texttt{Lib1} (the client library) to the method \texttt{Method10}. Therefore, \texttt{Method10} is not reachable form \texttt{Lib1} and the call from \texttt{Method6} to \texttt{Method10} will not be considered when measuring the transitive dependency between \texttt{Lib1} and \texttt{Lib3}, in the case of method invocation coupling.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{figures/Reachability.png}
\caption{Reachability example}
\label{fig:reachability}
\end{center}
\end{figure}

\paragraph{Propagation Factor}
The propagation represents how the impact of a change can spread across dependencies. In Figure \ref{fig:reachability}, a change in \texttt{Method3} would affect directly the client  library (\texttt{Lib1}). However, a change in \texttt{Method7}, affects first \texttt{Method3}, and then it can spread to \texttt{Method1}, in case it is not mitigated in \texttt{Method3}. This possible mitigation is accounted for by the \textit{Propagation Factor}.

\subsubsection{Formal definition}

\paragraph{Metric \#3: Transitive method invocation coupling (\texttt{TMIC})}
\todo{decide what to call each formula and whether to use indirect or transitive or something else}
If we look at how the metric $\verb|MIC|$ is calculated, it could be sumarized as: find all the methods in $L_s$ that are reachable from $L_c$. Then, for each one, count how many method calls exist in $L_c$ that reach this method, and sum up the results. The main difference between $\verb|MIC|$ and $\verb|TMIC|$ is that the calls in $L_c$ will not directly execute a reachable method of $L_s$. The execution of a method in $L_s$ is indirect, since $L_s$ is not a direct dependency of $L_c$.

Therefore, the indirect coupling between two libraries $\verb|IMIC|(L_c, L_s)$ is calculated in the following manner. For each method from $L_s$ that is reachable from $L_c$ throught method calls ($rm \in \verb|RM|(L_c,L_s)$), we count the number of method invocations in $L_c$ from which $rm$ is reachable, $\verb|nIR|(rm, L_c)$. The number of method invocations is multiplied by the number of polymorphic implementations of $rm$ in $L_s$ ($\verb|nDC|(rm, L_s)$).

\begin{equation}
\label{eqn:imic}
  \verb|IMIC|(L_c,L_s) = \sum_{rm \in \verb|RM|(L_c,L_s)} \verb|nIR|(rm,L_c) * \verb|nP|(rm, L_s)
\end{equation}

However, this formula does not consider propagation at all. Therefore, it is necessary to take into account the distance between $L_c$ and $L_s$. In addition, it could happen that $L_s$ is reachable from $L_c$ at different distances. For instance, if $L_s$ appeared twice in the dependency tree of $L_c$, this is is the case in Figure \ref{fig:dependency-tree} if we take \texttt{Lib1} as $L_c$ and \textit{Lib4} as $L_s$.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.4\textwidth]{figures/Thesis-DependencyTree.png}
\caption{Example dependency tree}
\label{fig:dependency-tree}
\end{center}
\end{figure}

Therefore, the previous formula for $|IMIC|(L_c,L_s)$ will be measured for a certain reachability $\verb|distance|$. \reminder{This formula will not be final until I have been able to measure it}
The Transitive Method Invocation Coupling ($\verb|TMIC|(L_c,L_s)$), will be measured as follows. For each $\verb|distance|$ at which there is coupling between $L_c$ and $L_s$, sum up the coupling measured by $\verb|IMIC|(L_c,L_s, \verb|distance|)$, multiplied by a propagation factor ($\verb|PF|$) to the power of the $\verb|distance|$. Where $\verb|PF| \in (0,1)$.
\unsure{Should this be to the power of (distance - 1)? This way, the distance = 1 (direct dependencies) are not mitigated by the propagation factor. Also, then distance = 2 (first level of transitivity) would only be mitigated once (which would correspond to the direct dependency)}

\begin{equation}
\label{eqn:tmic}
  \verb|TMIC|(L_c,L_s) = \sum_{\verb|distance|} \verb|IMIC|(L_c,L_s, \verb|distance|) * \verb|PF|^{\verb|distance|}
\end{equation}

\paragraph{Metric \#4: Transitive aggregation coupling (\texttt{TAC})}
In the case of aggregation coupling for the transitive dependencies ($\verb|IAC|(L_c,L_s)$), it is calculated in the following way. For each class of $L_s$ that is reachable from $L_c$ through field declarations ($rc \in \verb|RC|(L_c,L_s)$), count all the field declarations from which it is reachable ($\verb|nFR|(rc,L_c)$), and multiply it by the number of descendants of the reachable class ($\verb|nDC|(rm, L_s)$).

\begin{equation}
\label{eqn:iac}
  \verb|IAC|(L_c,L_s) = \sum_{rc \in \verb|RC|(L_c,L_s)} \verb|nFR|(rc,L_c) * \verb|nDC|(rm, L_s)
\end{equation}

Just as in the case of $\verb|TMIC|$, the $\verb|distance|$ between $L_c$ and $L_s$ should be considered. Therefore, for each $\verb|distance|$, we take the number measured by $\verb|IAC|(L_c,L_s, \verb|distance|)$, and multiply it by a propagation factor $\verb|PF|$ to the power of the $\verb|distance|$.

\begin{equation}
\label{eqn:tac}
  \verb|TAC|(L_c,L_s) = \sum_{\verb|distance|} \verb|IAC|(L_c,L_s, \verb|distance|) * \verb|PF|^{\verb|distance|}
\end{equation}

\subsubsection{Theoretical validation: TMIC}

\paragraph{Property 1: Nonnegativity}
Assume that nonnegativity does not hold for metric $\verb|TMIC|$. Then, there exists a client library $L_c$, and a server library $L_s$ such that $\verb|TMIC|(L_c, L_s) < 0$. According to equation \ref{eqn:tmic}, there is a $\verb|distance|$ for which either $\verb|IMIC|(L_c,L_s, \verb|distance|) < 0$ or $\verb|PF|^{\verb|distance|} < 0$. Since $\verb|distance|$ is a positive integer, and $\verb|PF| \in (0,1)$, the second option is not possible.

Let's assume that $\verb|IMIC|(L_c,L_s, \verb|distance|) < 0$. Looking at the equation \ref{eqn:imic}, we see that there has to be at least one method, $rm$, from $L_s$ and reachable from $L_c$ ($rm \in \verb|RM|(L_c,L_s)$), such that $\verb|nIR|(rm,L_c) < 0$ or $\verb|nP|(rm, L_s) < 0$. Since $\verb|nP|(rm, L_s)$ corresponds to the number of polymorphic implementations of $rm$ in $L_s$, and we know that $rm$ belongs to $L_s$, then $\verb|nP|(rm, L_s) \geq 1$. Finally, for $\verb|nIR|(rm,L_c) < 0$ to be true, there should be less than zero method invocations in $L_c$ from which $rm$ is reachable. However, since $rm \in \verb|RM|(L_c,L_s)$, and $\verb|RM|(L_c,L_s)$ corresponds to the set of methods from $L_s$ that are reachable from $L_c$, we have that $\verb|nIR|(rm,L_c) \geq 1$, which constitutes a contradition.

Therefore, the metric $\verb|TMIC|$ fulfills the property \textit{Nonnegativity}.

\paragraph{Property 2: Null value}
Assuming that $\verb|TMIC|$ does not fulfill property \textit{Null value}, there exists a client library $L_c$, and a server library $L_s$ such that $\verb|R|(L_c, L_s) = \emptyset$ and $\verb|TMIC|(L_c, L_s) \neq 0$.

For $\verb|TMIC|(L_c, L_s) \neq 0$ to be true, according to equation \ref{eqn:imic}, there has to be a method $rm$ such that  $rm \in \verb|RM|(L_c,L_s)$. However, that would mean that $rm$ belongs to $L_s$, and is reachable from $L_c$, which constitutes a relation between $L_c$ and $L_s$, and contradicts $\verb|R|(L_c, L_s) = \emptyset$.

Hence, the property \textit{null value} holds for metric $\verb|TMIC|$ .

\paragraph{Property 3: Monotonicity}
Let $L_c$ be a client library containing class $c_c$, and $c_c'$ be a class resulting from adding relationships with the server library $L_s$ to class $c_c$. Then, $\verb|R|(c_c, L_s) \subseteq \verb|R|(c_c', L_s)$. Let $L_c'$ be a client library resulting from replacing class $c_c$ by $c_c'$ in $L_c$. Therefore, $\verb|R|(L_c, L_s) \subseteq \verb|R|(L_c', L_s)$.

If we assume that $\verb|TMIC|$ does not fulfill property \textit{Monotonicity}, it would be true that $\verb|TMIC|(L_c, L_s) > \verb|TMIC|(L_c', L_s)$. Therefore, for a certain distance, we have that $\verb|IMIC|(L_c,L_s) > \verb|IMIC|(L_c',L_s)$, according to equation \ref{eqn:tmic}. According to the equation \ref{eqn:imic}, this opens two possibilities.

First, we have that $|\verb|RM|(L_c,L_s)| > |\verb|RM|(L_c',L_s)|$, which means that there are more methods from $L_s$ reachable from $L_c$ than from $L_c'$. This is not possible since, the only difference between $L_c$ and $L_c'$ is the substitution of class $c_c$ by class $c_c'$, which only adds relationships with $L_s$.

The second option is that for a certain $rm \in \verb|RM|(L_c,L_s)$, and therefore also $rm \in \verb|RM|(L_c',L_s)$, such that   $\verb|nIR|(rm,L_c) > \verb|nIR|(rm,L_c')$. However, that means that in $L_c$ there are more method invocations that reach $rm$, than in $L_c'$. As discussed earlier, this constitutes a contradicion with the way $L_c'$ is created.

Therefore, property 3 \textit{Monotonicity} holds for $\verb|TMIC|$.

\paragraph{Property 4: Merging of classes}
Let $L_c$ be a client library that includes the classes $c_1$ and $c_2$. Let $c'$ be a class such that $c_1 + c_2 = c'$ and $L_c'$ be a client library resulting from replacing $c_1$ and $c_2$ by $c'$ in $L_c$. If we assume that the property merging of classes does not hold for $\verb|TMIC|$, then $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$ and $\verb|TMIC|(L_c, L_s) > \verb|TMIC|(L_c', L_s)$.

Since the only difference between $L_c$ and $L_c'$ is the replacement of $c_1$ and $c_2$ by $c'$, there has to be a method invocation from $c_1$ or $c_2$ to a method $rm \in \verb|RM|(L_c,L_s)$, which is not included in $c'$. However, the method invocation has to be a relation included in $\verb|R|(c_1, L_s)$ or $\verb|R|(c_2, L_s)$, and we have that $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$. Therefore it is a contradiction.

Hence, the property \textit{Merging of classes} holds for $\verb|TMIC|$.

\paragraph{Property 5: Merging of unconnected classes}
Let $L_c$ be a client library and $L_s$ be a server library. Let $c_1$ and $c_2$ be classes implemented in $L_c$, such that $\verb|R|(c_1, L_s) \cap \verb|R|(c_2, L_s) = \emptyset$. Let $c'$ be a class such that $c_1 + c_2 = c'$. Therefore, $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$. Let $L_c'$ be a client library identical to $L_c$ but in which $c_1$ and $c_2$ have been replaced by $c'$. We assume that the metric $\verb|TMIC|$ does not fulfill this property.

Therefore, $\verb|TMIC|(L_c, L_s) \neq \verb|TMIC|(L_c', L_s)$. According to property \textit{Merging of classes}, $\verb|TMIC|(L_c, L_s) \geq \verb|TMIC|(L_c', L_s)$. Hence, $\verb|TMIC|(L_c, L_s) > \verb|TMIC|(L_c', L_s)$.

Then, there is a method invocation is $c_1$ or $c_2$ which is not included in $c$, which contradicts that $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$.

We conclude that $\verb|TMIC|$ fulfills property \textit{Merging of unconnected classes}.

\subsubsection{Theoretical validation: TAC}

\paragraph{Property 1: Nonnegativity}
Assuming that nonnegativity does not hold for metric $\verb|TAC|$, there exists a client library $L_c$, and a server library $L_s$ such that $\verb|TAC|(L_c, L_s) < 0$. In line with equation \ref{eqn:tac}, there is a $\verb|distance|$ for which two things can happen. First, $\verb|PF|^{\verb|distance|} < 0$. However, since $\verb|distance|$ is a positive integer, and $\verb|PF| \in (0,1)$, this is not possible.

The scond option is that $\verb|IAC|(L_c,L_s, \verb|distance|) < 0$. Looking at the equation \ref{eqn:iac}, we see that there has to be at least one class, $rc \in \verb|RC|(L_c,L_s)$, that belongs to $L_s$ and is reachable from $L_c$, such that $\verb|nFR|(rc,L_c) < 0$ or $\verb|nDC|(rm, L_s) < 0$. $\verb|nDC|(rm, L_s)$ is the number of descendants of $rc$ in $L_s$. Ad we know that $rc$ belongs to $L_s$, we have that $\verb|nDC|(rm, L_s) \geq 1$.

Finally, if $\verb|nFR|(rc,L_c) < 0$ is true, there are less than zero field declarations in $L_c$ from which $rc$ is reachable. However, since $rc \in \verb|RC|(L_c,L_s)$, and $\verb|RC|(L_c,L_s)$ corresponds to the set of classes from $L_s$ that are reachable from $L_c$ through field declarations, we have that $\verb|nFR|(rc,L_c) \geq 1$, which constitutes a contradition.

Therefore, the property \textit{Nonnegativity} holds for metric $\verb|TAC|$.

\paragraph{Property 2: Null value}
Let's assume that $\verb|TAC|$ does not fulfill property \textit{Null value}. Therefore, there exists a client library $L_c$, and a server library $L_s$ such that $\verb|R|(L_c, L_s) = \emptyset$ and $\verb|TAC|(L_c, L_s) \neq 0$.

If $\verb|TAC|(L_c, L_s) \neq 0$ then, as stated in equation \ref{eqn:iac}, there has to be a class $rc$ such that  $rc \in \verb|RC|(L_c,L_s)$. However, if $rc \in \verb|RC|(L_c,L_s)$, then $rc$ belongs to $L_s$, and is reachable from $L_c$. This creates a relation between $L_c$ and $L_s$, and therefore contradicts $\verb|R|(L_c, L_s) = \emptyset$.

In conclusion, the property \textit{Null value} holds for metric $\verb|TAC|$.

\paragraph{Property 3: Monotonicity}
Assuming that property \textit{Monotonicity} does not hold for metric $\verb|TAC|$, let $L_c$ be a client library containing class $c_c$, and $L_s$ be a server library. Also, let $c_c'$ be the resulting class of adding new relationships with $L_s$ to class $c_c$. Then, $\verb|R|(c_c, L_s) \subseteq \verb|R|(c_c', L_s)$. Let $L_c'$ be the client library resulting from replacing class $c_c$ by $c_c'$ in $L_c$. Therefore, $\verb|R|(L_c, L_s) \subseteq \verb|R|(L_c', L_s)$.

Since $\verb|TAC|$ does not fulfill property \textit{Monotonicity}, we have that $\verb|TAC|(L_c, L_s) > \verb|TAC|(L_c', L_s)$. Hence, for a certain distance, it is true that $\verb|IAC|(L_c,L_s) > \verb|IAC|(L_c',L_s)$, according to equation \ref{eqn:tac}. As equation \ref{eqn:iac} indicates, this can be true in two cases.

The first option is $|\verb|RC|(L_c,L_s)| > |\verb|RC|(L_c',L_s)|$.
In other words, there are more classes from $L_s$ reachable from $L_c$ than from $L_c'$. Since the only difference between $L_c$ and $L_c'$ is the replacement of class $c_c$ by $c_c'$, and according to the definition of class $c_c'$, this is not possible.

Therefore, the last option is that there is a class $rc \in \verb|RC|(L_c,L_s) \land rm \in \verb|RM|(L_c',L_s)$, such that   $\verb|nFR|(rc,L_c) > \verb|nFR|(rc,L_c')$. This implies that the number of field declarations that reach $rc$ in $L_c$is greater than in $L_c'$, which is a contradicion with the definition of $L_c'$.

Therefore, property \textit{Monotonicity} holds for $\verb|TAC|$.

\paragraph{Property 4: Merging of classes}
Let $L_c$ be a client library, and let classes $c_1$ and $c_2$ be classes implemented in $L_c$. Also, let $c'$, created as follows $c' = c_1 + c_2$, and $L_c'$ be a client library based on $L_c$ in which $c_1$ and $c_2$ have been replaced by $c'$. Assuming \textit{merging of classes} does not hold for $\verb|TAC|$, we have that $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s) \land \verb|TAC|(L_c, L_s) > \verb|TAC|(L_c', L_s)$.

$L_c$ and $L_c'$ are only different in the replacement of $c_1$ and $c_2$ by $c'$. Hence, there has to be a field declaration from $c_1$ or $c_2$ which reaches a class $rc \in \verb|RC|(L_c,L_s)$, and is not found in $c'$. However, the reachability through a field declaration is a relation included in $\verb|R|(c_1, L_s)$ or $\verb|R|(c_2, L_s)$, and we have that $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$, which constitutes a contradiction.

Therefore, $\verb|TAC|$ fulfills property \textit{Merging of classes}.

\paragraph{Property 5: Merging of unconnected classes}
Let $L_c$ and $L_s$ be a client and a server library respecively. Let $c_1$ and $c_2$ be classes implemented in $L_c$, such that $\verb|R|(c_1, L_s) \cap \verb|R|(c_2, L_s) = \emptyset$. Let $c'$ defined as $c' = c_1 + c_2$. Hence, $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$. Let $L_c'$ be a client library which is the result of replacing $c_1$ and $c_2$ by $c'$ in $L_c$.

Assume that the $\verb|TAC|$ does not fulfill \textit{Merging of unconnected classes}. This means that $\verb|TAC|(L_c, L_s) \neq \verb|TAC|(L_c', L_s)$. Since $\verb|TAC|$ has the property \textit{Merging of classes}, we know that $\verb|TAC|(L_c, L_s) \geq \verb|TAC|(L_c', L_s)$, which leaves $\verb|TAC|(L_c, L_s) > \verb|TAC|(L_c', L_s)$.

Then, there exists a field declaration in $c_1$ or $c_2$ which reaches a class included in $L_s$ and is not included in $c$. However, we have that $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$, which creates a contradiction.

Therefore, the metric $\verb|TAC|$ fulfills property \textit{Merging of unconnected classes}.

\section{Measuring usage of the dependency}
\unsure{Should I talk about usage or maybe about coverage?}
The metrics presented in this section measure the dependencies from a diferent perspective. Instead of measuring import coupling between the client library and the serverlibrary, we look at how much of the server library is used by the client library.

\unsure{Maybe explain why? To know if that library is really necessary, or only a submodule is needed, to see if there is another library that offers only the functionality that you use, to know which is the probability that a breaking change affects your code...}

\subsection{Definition of usage}\label{subsect:usage-definition}
Just as with the coupling metrics, it is necessary to define which are the characteristics of the usage that is going to be measured. In this case, there is no framework indicating which are the relevant characteristics to define, and with which criteria.

Therefore, based on the critera discussed for the definition of coupling, we have created the list of the criterion applicable in the case of the usage of a dependency.

\paragraph{Type of connection}
For these metrics, since it is not about coupling, but about how much of the server library is used by the client library, the metrics will not be focused solely on one type of connection. Instead, we will consider every type of connection as a usage.

In addition, the types of connection discussed previously (see section \ref{subsect:defCoupling}), which are some of the most common types of connection, there are others which are also considered.

Given class \textit{a} and class \textit{b}...

\begin{itemize}
  \item ... class \textit{a} has an annotation of type \textit{b}.
  \item ... class \textit{a} has method \textit{m}, which has an annotation of type \textit{b}.
  \item ... class \textit{a} has method \textit{m}, which has a parameter with an annotation of type \textit{b}.
  \item ... class \textit{a} has method \textit{m}, which throws an exception of type \textit{b}.
\end{itemize}

\paragraph{Granularity}
In this case we have to define what is a unit, to measure which percentage of units of the server library are being used by the client library. According to the type of connections, there are two diferent kind of units that can be used: methods and classes. Therefore, we define two metrics, one for each of the units. Nevertheless, the aggregation level of the metrics, is still the library level. Since the goal is to measure the percentage of units used.

The last aspect of the granularity to consider is how are the connections evaluated. Since the goal is not to know how many times a connection takes place, we count the distinct items at the other end of the connections.

\paragraph{Direct \& Indirect}
Finally, we have to decide whether to consider indirect usage or not. Since we want to know the total percentage of usage of the server library, we will consider both, the units that are directly used and those that are indirectly used.

\unsure{Decide whether to add inheritance criterion or not}

\paragraph{Result}

\begin{table}[h]
    \begin{center}
    \begin{tabular}{|l|l|l|l|l|l|}
    \hline
    \rot{Metric} & \rot{Type of connection} & \rot{Unit of measure} & \rot{Aggregation level} & \rot{Counting connections    } & \rot{Direct/Indirect} \\ \hline
    \% Used classes & All & Class   & Library & Distinct items & Both \\
    \% Used methods & All & Method  & Library & Distinct items & Both \\
    \hline
    \end{tabular}
    \end{center}
    \caption{Criteria of the set of metrics}
    \label{table:usage-metric-characteristics}
\end{table}

\subsection{Formal definition of the metrics}

\subsubsection{Percentage of reachable classes}
This metric calculates the percentage of usage of a dependency using classes as the unit of measure. Therefore, it calculates the cardinality of the set of classes implemented in the server library ($L_s$) that are reachable from the code of the client library ($L_c$), denoted $\verb|RC|(L_c, L_s)$. The number of reachable classes is divided by the total number of classes in $L_s$.

As explained in section \ref{subsect:usage-definition}, all types of connections are considered for this metric. Hence, $\verb|RC|(L_c, L_s)$ includes all the classes reachable through any of the types of connection, or a combination of these.

\begin{equation}
\label{eqn:reachable-classes}
    \verb|%ReachableClasses|(L_c, L_s) = \frac{|RC(L_c, L_s)|}{|C(L_s)|}
\end{equation}

\subsubsection{Pergentage of reachable methods}
This metric works exactly as the previous one, but instead of using class as the unit of measure, it uses methods. Therefore, it divides the number of elements in the set of methods from the server library ($L_s$) that are reachable from the code of the client library ($L_c$), $RM(L_c, L_s)$, by the total number of methods ($|M(L_s)|$).

For this metric, since the unit of measure is the method, the only type of connection through which a method is reachable is the method call or method invocation. Thus, the methods included in the reachable classes, are not considered reachable by default, since it is not sure if the method has been invoked.

\begin{equation}
\label{eqn:reachable-methods}
\verb|%ReachableMethods|(L_c, L_s) = \frac{|RM(L_c, L_s)|}{|M(L_s)|}
\end{equation}

\subsection{Theoretical validation}\label{subsect:theoretical-validation-usage}
In this section, the theoretical validation of the metrics $\verb|\%ReachableClasses|$ and $\verb|\%ReachableMethods|$ is done by proving the properties that these metrics should fulfill. Given that the two metrics are highly similar, the proofs are done for the first metric, namely $\verb|\%ReachableClasses|$, but could easily be done for the second one with the same reasoning.

The properties chosen for these metrics are the ones that the element being measured should have. We based the properties to be proven on the work by Srinivasan and Devi \cite{srinivasan2014software}, which reviews the methodologies to validate metrics in software engineering. We obtained the following list of properties, which are applicable to these metrics. The first two properties were originally described by Weyuker \cite{weyuker1988evaluating} and the last three by Briand et al. \cite{briand1996property}. Some properties are originally defined using class as the aggregation level. Therefore, we adapted the properties to be used with the library aggregation level.

\begin{enumerate}
  \item \textbf{Noncoarseness:} Two different libraries can have different values for the same metric.
  \item \textbf{Nonuniqueness:} There can exist different libraries with the same value.
  \item \textbf{Nonnegativity:} The value of the metric should never be negative.
  \item \textbf{Null value:} The value of the metric is expected to be zero if there is no usage of the server library in the code of the client library.
  \item \textbf{Monotonicity:} It is expected that if more usage is added from the client library to the server library, the value of the metric does not decrease.
\end{enumerate}

\paragraph{Property 1: Noncoarseness}
Let's take the two cases in Figure \ref{fig:example-noncoarseness-reachable-classes}. In the first case, \textit{Lib1} would be the client library, and \textit{Lib2} the server library. In the example, we can see that the number of classes in the server library is: $|\verb|C|(Lib2)| = 3$. Also, the number of classes of the server library, reached by the client library is $|RM(Lib1, Lib2)| = 2$. Therefore, following the equation \ref{eqn:reachable-classes}, we have that $\verb|%ReachableClasses|(Lib1, Lib2) = \frac{2}{3} = 0.66$.

In the second case in Figure \ref{fig:example-noncoarseness-reachable-classes} we take \textit{Lib3} as the client library, and \textit{Lib4} as the server library. Therefore, we have $|\verb|C|(Lib4)| = 3$ and $|RM(Lib3, Lib4)| = 3$, which means that the value of the metric is  $\verb|%ReachableClasses|(Lib3, Lib4) = \frac{3}{3} = 1$.

Therefore, two different libraries can have different values for $\verb|%ReachableClasses|$, which means that this metric fulfills the property \textit{Noncoarseness}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{figures/Example-Percentage-Classes-1.png}
\caption{Example of noncoarseness, percentage of reachable classes}
\label{fig:example-noncoarseness-reachable-classes}
\end{center}
\end{figure}

\paragraph{Property 2: Nonuniqueness}
Following the first example in Figure \ref{fig:example-nonuniqueness-reachable-classes} we take \textit{Lib1} as the client library, and \textit{Lib2} the server library. Therefore, we can see that $|\verb|C|(Lib2)| = 3$, and $|RM(Lib1, Lib2)| = 2$. Hence, calculating the metric using equation \ref{eqn:reachable-classes}, we obtain $\verb|%ReachableClasses|(Lib1, Lib2) = \frac{2}{3} = 0.66$.

In the second case in Figure \ref{fig:example-noncoarseness-reachable-classes} we have \textit{Lib3} as the client library, and \textit{Lib4} as the server library. Looking at the example, we know that $|\verb|C|(Lib4)| = 3$ and $|RM(Lib3, Lib4)| = 2$. Therefore, the metric for these two libraries is $\verb|%ReachableClasses|(Lib3, Lib4) = \frac{2}{3} = 0.66$.

Therefore, two different libraries can have the same value for metric $\verb|%ReachableClasses|$. Hence, the property \textit{Nonuniqueness} holds for this metric.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{figures/Example-Percentage-Classes-2.png}
\caption{Example of nonuniqueness, percentage of reachable classes}
\label{fig:example-nonuniqueness-reachable-classes}
\end{center}
\end{figure}

\paragraph{Property 3: Nonnegativity}
Assume that the metric $\verb|%ReachableClasses|$ does not fulfill this property.
Let $L_c$ be a client library, and $L_s$ be a server library, such that $\verb|%ReachableClasses|(L_c, L_s) < 0$. Then, we have that $|RC(L_c, L_s)| < 0 \oplus |C(L_s)| < 0$. This means that the cardinality of a set is negative, which is not true by definition. Therefore, it is a contradition.

Hence, the metric fulfills property \textit{Nonnegativity}.

\paragraph{Property 4: Null value}
Let $L_c$ be a client library, and $L_s$ be a server library. There is no usage in $L_c$ of library $L_s$, $RC(L_c, L_s) = \emptyset$. Assuming that the property null value does not hold for $\verb|%ReachableClasses|$, then $\verb|%ReachableClasses|(L_c, L_s) \neq 0$. Since this metric has the property nonnegativity, then  $\verb|%ReachableClasses|(L_c, L_s) > 0$.
Therefore, $\frac{|RC(L_c, L_s)|}{|C(L_s)|} > 0$ and $|RC(L_c, L_s)| > 0$, which contradicts that $RC(L_c, L_s) = \emptyset$.

Therefore, the property \textit{Null value} holds for metric $\verb|%ReachableClasses|$.

\paragraph{Property 5: Monotonicity}
Having $L_c$ a client library, and $L_s$ a server library. Let $c_c$ be a class in $L_c$, and $c_c'$ a class created as the result of adding more connections to $L_s$ in $c_c$. Then, let $L_c'$ be a client library resulting of replacing $c_c$ by $c_c'$ in $L_c$. Assuming that the property does not hold, we would have that $\verb|%ReachableClasses|(L_c, L_s) > \verb|%ReachableClasses|(L_c', L_s)$.
Therefore, since $|C(L_s)|$ is the same in both cases because $L_s$ does not change, we have that $|RC(L_c, L_s)| > |RC(L_c', L_s)|$. This means that there is some $c_s$ in $L_s$, which is reachable from $c_c$ and not reachable from $c_c'$. However, $c_c'$ contains all the connections between $c_c$ and $L_s$, and that is therefore not possible.

In conclusion, the metric $\verb|%ReachableClasses|$ has the property \textit{Monotonicity}.

\section{Measuring impact per class}
\unsure{I'm not sure if impact is really the word I want to use here, I'm still thinking about it}
\unsure{Also, I'm not sure about the level of detail needed for these metrics, since it seems pretty simple. Let me know if there is something I should remove or add. Or if I should not treat these as metrics in the same way as the others}

In this case, the goal is to give a bit more low level information of the impact of the dependency in the client library. From the point of view of a developer or a maintainer, it can be useful to know exactly which parts of your code can be impacted by the dependency. For example, in case there is a breaking change, or if the library with which there is a dependency, has to be replaced.

In this section, we describe how is impact measured by these metrics and provide a formal definition of the metrics. Finally, we perform a theoretical validation of the metrics.

\subsection{Definition of impact}
To define the impact to be measured by these metrics, we use the relevant criteria for this case.

\paragraph{Type of connection}
Just as with the coupling metrics, all the types of connection can be relevant, but probably the impact of each type of connection is different. Therefore, these should not be measured together. Since this work is meant to be a first approach we select two of the possible types of connection.

First, the \textit{method invocation}, since it is the only type of connection which refers to the methods used in the dependencies, and therefore is the only one indicating where the methods of the server libraries can be invoked from. Then, to have a representation as well of how the classes of the server libraries are used, and for consistency with the previous metrics, we select the \textit{field declaration}.

\paragraph{Granularity}

As the title of the section indicates, these metrics are measuring the impact \textit{per class}. Hence, the aggregation level of the metric is the \textit{class} level for the client library. In other words, we calculate the metric taking a class of the client library, and a server library.

With respect to the way the connections are counted is not considered in the original list created by Briand et al. \cite{briand1999unified}. Instead, it is counted the number of places of the client class where a connection is originated. For instance, let's take \textit{Lib1} from Figure \ref{fig:example-impact-per-class} as the client library, and \textit{Lib3} as the server library. From \textit{Class1} to \textit{Lib3} there are four different connections, but there are only two origins of these connections. The same happens with \textit{Class2}, in which there are two connections with \textit{Lib3}, but only one origin.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{figures/impact-per-class.png}
\caption{Example to calculate impact per class}
\label{fig:example-impact-per-class}
\end{center}
\end{figure}

\paragraph{Direct \& Indirect}

The connection measured can be either direct or indirect, depending on the type of dependency between the client and the server library. However, this does not change the calculation of the metric, hence, both types of dependencies are calculated with the same metric.

\paragraph{Result}
Based on the criteria discussed above, we define two metrics. The summary of the characeristics of these two metrics can be found in Table \ref{table:per-class-characteristics}.

\begin{table}[h]
    \begin{center}
    \begin{tabular}{|l|l|l|l|}
    \hline
    Type of connection & Aggregation level & Counting connections & Direct/Indirect \\ \hline
    Method invocation & Class & \#origin of connection & Both \\
    Field declaration & Class & \#origin of connection & Both \\
    \hline
    \end{tabular}
    \end{center}
    \caption{Criteria of the set of metrics}
    \label{table:per-class-characteristics}
\end{table}

\subsection{Formal definition of the metrics}
\unsure{I am not sure about which names to use here}

\paragraph{Method invocations per class}
Having a client library ($L_c$), and a server library ($L_s$). The result of this metric for a class of the client library ($c_c \in \verb|C|(L_c)$) corresponds to the number of method invocations contained in the methods of $c_c$ ($m_c \in \verb|M|(c_c)$) such that, the call graph created from these method invocations reach a method implemented in the client library ($m_s \in \verb|M|(L_s)$). The set with the method invocations in $m_c$ that reach a method in $L_s$ is $\verb|nIR|(m_c, L_s)$.

\begin{equation}
\label{eqn:mi}
    \verb|#MethodInvocations|(c_c, L_s) =  \sum_{m_c \in \verb|M|(c_c)} |\verb|nIR|(m_c, L_s)|
\end{equation}

\paragraph{Field declaration per class}
This metric is calculated in the following manner. For a class $c_c$ of a client library $L_c$ ($c_c \in \verb|C|(L_c)$), and a server library $L_s$. The result of the metric for $c_c$, corresponds to the number of field declarations in $c_c$ such that, through field declarations reach a class implemented in $L_s$. The set of field declarations that reach $L_s$ is denoted $\verb|nFR|(c_c, L_s)$.

\begin{equation}
\label{eqn:fd}
    \verb|#FieldDeclarations|(c_c, L_s) = |\verb|nFR|(c_c, L_s)|
\end{equation}

\subsection{Theoretical validation}
This section contains the proofs, for the metrics $\verb|#MethodInvocations|$ and $\verb|#FieldDeclarations|$, of the properties that these should have. The proofs are done for one metric, since they can be done for the other metric very similarly.

The properties chosen in this case, are the same as the ones chosen in section \ref{subsect:theoretical-validation-usage}, since these properties can also be applied for these metrics. Nevertheless, the description of the properties has been adapted to fit the characteristics of the metrics.

\begin{enumerate}
  \item \textbf{Noncoarseness:} Two different classes can have different values for the same metric.
  \item \textbf{Nonuniqueness:} There can exist different classes with the same value.
  \item \textbf{Nonnegativity:} The value of the metric should never be negative.
  \item \textbf{Null value:} The value of the metric is expected to be zero if there is no connection of the type measured by the metric from the client class, to the server library.
  \item \textbf{Monotonicity:} It is expected that if more usage is added from the client class to the server library, the value of the metric does not decrease.
\end{enumerate}

\paragraph{Property 1: Noncoarseness}
Following the first case in Figure \ref{fig:example-noncoarseness-method-invocation}, we take textit{Lib1} as the client library, \textit{Lib2} as the server library, and the only class in \textit{Lib1} as $c_c$. We can see that the class has only one method, for which $|\verb|nIR|(Method, Lib2)| = 1$. Therefore, following the equation \ref{eqn:mi}, we have that $\verb|#MethodInvocations|(c_c, Lib2) = 1$.

Now we move to the second case in Figure \ref{fig:example-noncoarseness-method-invocation}. In this case we take \textit{Lib3} as the client library, \textit{Lib4} as the server library, and the class in \textit{Lib3} as $c_c$. $c_c$ has only one method, for which $|\verb|nIR|(Method, Lib4)| = 3$. Hence, $\verb|#MethodInvocations|(c_c, Lib4) = 3$.

In conclusion, two different classes can have different values for metric $\verb|#MethodInvocations|$, which fulfills property \textit{Noncoarseness}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{figures/Example-Distribution-1.png}
\caption{Example of noncoarseness, number of method invocations}
\label{fig:example-noncoarseness-method-invocation}
\end{center}
\end{figure}

\paragraph{Property 2: Nonuniqueness}
Now we look at Figure \ref{fig:example-nonuniqueness-method-invocation}, and in the first example we take \textit{Lib1} as the client library, \textit{Lib2} the server library, and the class in \textit{Lib1} as the client class, $c_c$. The client class has only one method, for which $|\verb|nIR|(Method, Lib2)| = 2$. Therefore, the value of the metric in this case, is as follows, $\verb|#MethodInvocations|(c_c, Lib2) = 2$.

Focusing on the second case in Figure \ref{fig:example-nonuniqueness-method-invocation}, we have that \textit{Lib3} is the client library and \textit{Lib4} the server library. Also, the client class, $c_c$, is the only class in \textit{Lib3}. We can see that there is one method in $c_c$, which calls \textit{Lib4} a total of 2 times, $|\verb|nIR|(Method, Lib4)| = 2$. Hence, $\verb|#MethodInvocations|(c_c, Lib4) = 2$.

With this example we see that two different classes can have the same value for $\verb|#MethodInvocations|$. Therefore, this metric fulfills the property \textit{Nonuniqueness}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{figures/Example-Distribution-2.png}
\caption{Example of nonuniqueness, number of method invocations}
\label{fig:example-nonuniqueness-method-invocation}
\end{center}
\end{figure}

\paragraph{Property 3: Nonnegativity}
Assuming that the property does not hold for $\verb|#MethodInvocations|$, let $L_c$ be a client library containing $c_c$. Let $L_s$ be a server library, such that $\verb|#MethodInvocations|(c_c, L_s)
< 0$. Therefore, exsists a method $m_c \in \verb|M|(c_c)$, such that $|\verb|nIR|(m_c, L_s)| < 0$. However, the cardinality of a set cannot be negative by definition, and therefore it is a contradition.

Hence, the property \textit{Nonnegativity} holds for metric $\verb|#MethodInvocations|$.

\paragraph{Property 4: Null value}
Assume that the metric does not fulfill property null value. Let $L_c$ and $L_s$ be a client library and a server library, adn $c_c$ a class in $L_c$. Assume that $c_c$ does not have any connection to $L_s$, and given that the metric does not fulfill \textit{null value}, $\verb|#MethodInvocations|(c_c, L_s) \neq 0$. From the previous proof we know that $\verb|#MethodInvocations|(c_c, L_s) \geq 0$, then  $\verb|#MethodInvocations|(c_c, L_s) > 0$.
Hence, there is a method $m_c \in \verb|M|(c_c)$ such that $|\verb|nIR|(m_c, L_s)| > 0$. Since $\verb|nIR|(m_c, L_s)$ is the set of method invocations in $c_c$ that reach $L_s$, there has to be a connection between $c_c$ and $L_s$, which constitutes a contradition.

Therefore, the metric fulfills property \textit{Null value}.

\paragraph{Property 5: Monotonicity}
Let $L_c$ be a client library, and let $L_s$ be a server library. Given a class $c_c$ in $L_c$, we define $c_c'$ as a copy $c_c$ with added connections to $L_s$. Let $L_c'$ be a client library identical to $L_c$,. but in which $c_c$ has been replaced by $c_c'$. Assume that metric $\verb|#MethodInvocations|$ does not fulfill \textit{Monotonicity}. Therefore, $\verb|#MethodInvocations|(c_c, L_s) > \verb|#MethodInvocations|(c_c, L_s)$.
Then, for a given $m_c \in \verb|M|(c_c)$, and its copy in $c_c'$, $m_c' \in \verb|M|(c_c')$, such that $|\verb|nIR|(m_c, L_s)| > |\verb|nIR|(m_c', L_s)|$. This means that $m_c$ contains a method invocation which reaches $L_s$ and it is not included in $m_c'$. However, all the method invocations contained in $c_c$ are maintained in $c_c'$. Therefore, it is a contradition.

Hence, property \textit{Monotonicity} holds for metric $\verb|#MethodInvocations|$.
