% !TEX root = ../main.tex
\chapter{Dependency evaluation model}\label{ch:TheoreticModel}
This chapter contains a description of the metrics proposed to measure dependencies from various points of view: coupling, coverage, and usage per class. Each metric is also validated theoretically, by proving the metrics fulfill certain properties that the aspect being measured has.

\section{Measuring the degree of dependency}\label{sect:degree-dependency}
Although we have not been able to find any other research which proposes metrics to measure the degree of code dependency in a dependency with a library, this has been previously done to measure the degree of dependency within a library, or any other software product. The type of metrics used are coupling metrics. Therefore, we are going to define coupling metrics which can be used in our use case. In order to create the metrics, we first need to define the coupling we measure. Then, we define the metrics which measure the type of coupling defined. Finally, the five properties of coupling established in the literature \cite{briand1996property}, are proven for the designed metrics.

\subsection{Definition of coupling}\label{subsect:defCoupling}
To measure the degree of dependency, we investigate the characteristics of the coupling between libraries. Following the framework defined by Briand et al. \cite{briand1999unified}, described in Section~\ref{section:bg-coupling}, we define the coupling to measure according to the six criteria in the framework, which were defined based on the characteristics of existing coupling definitions.

\paragraph{Criterion 1 - Type of connection:}
This criterion defines which type of connection creates coupling between the two items. Several and clearly distinguishable mechanisms can create coupling, as defined by Briand et al. \cite{briand1999unified}, listed below.

\blankls
Given class \textit{a} of library \textit{A}, and class \textit{b} of library \textit{B}...

\begin{enumerate}
  \item ... class \textit{a} has an attribute of type \textit{b} (Relationship of aggregation).
  \item ... method of class \textit{a} has a parameter of type \textit{b} or has return type \textit{b}.
  \item ... method of class \textit{a} has a local variable of type \textit{b}.
  \item ... method of class \textit{a} calls a method which has a parameter of type \textit{b}.
  \item ... method of class \textit{a} references an attribute of class \textit{b}.
  \item ... method of class \textit{a} invokes a method of class \textit{b}.
  \item ... class \textit{a} and class \textit{b} have a relationship such as uses or consists-of.
\end{enumerate}

Having a single metric measure more than one of these types of connections is not recommended for various reasons. To begin with, the strengths of every type of connection have to be justified: Has the coupling created by a local variable (type 5) the same strength as the one created by a method invocation (type 6)? How is the strenght quantified? Also, when mixing types of connections, there is information missing; it is impossible to know how much of the coupling is created by which type of connection, and therefore which fix has a priority. Therefore, all relevant types of connections in the use case of RQ1, measuring the degree of dependencies between libraries, are measured by different metrics.

To decide which types of connections to measure, we reviewed the literature on coupling metrics to understand which connections are the most measured and why. Our findings are summarized in Table~\ref{tab:type-con-literature}.

\begin{table}[ht!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
         \hline
         Reference                      & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\hline
         \cite{eder1994coupling}        & x & x & x & x &   & x & x \\\hline
         \cite{hitz1995measuring}       & x & x & x &   & x & x & x \\\hline
         \cite{briand1997investigation} & x & x &   &   &   & x &   \\\hline
         \cite{wilkie2000coupling}      & x & x &   &   &   &   &   \\\hline
         \cite{yang2005detecting}       & x & x & x & x &   & x &   \\\hline
         \cite{gui2007ranking}          & x &   &   &   & x & x &   \\\hline
         \cite{gupta2009package}        & x & x & x & x & x & x & x \\\hline
         \cite{harrison1998coupling}    &   &   &   &   & x & x &   \\\hline
         \cite{du2004refactoring}       & x &   &   &   & x & x &   \\\hline
         \cite{koetter2019assessing}    & x &   &   &   & x & x &   \\\hline
    \end{tabular}
    \caption{Literature usage of the types of connection}
    \label{tab:type-con-literature}
\end{table}

Types 1 and 6 are the most used in the literature and, in particular, method invocation coupling is
hypothesized to be the most relevant type of connection by Briand et al. \cite{briand1999unified}. Therefore, we define a first metric to measure \textbf{type 6: method invocation}.

The second metric that we consider is \textbf{type 1: aggregation coupling}, for two key reasons. First, it is used as much as type 6 in the reviewed literature. Besides, in some cases, measuring method invocations may not be enough to understand how much impact a dependency may have on a library. There is the possibility that a class contains a field with the type of another class but never calls a method that belongs to that class.

The above-mentioned types of connections are those that we consider for these metrics, and we will explain them in greater detail in Section~\ref{section:defMetrics}. Nevertheless, it might be necessary to include additional metrics in the future, to account for other connection types.We discuss this in the experiment 2 (see Section \ref{sec:experiment2}).

\paragraph{Criterion 2 - Locus of impact:}
As explained in Section~\ref{section:bg-coupling}, Briand et al. define two options for the locus of impact: import and export \cite{briand1999unified}. According to the definition of the problem, this measurement aims to know how much a library depends on another, from the point of view of the library that uses another one. Hence, the locus of impact of the coupling to be measured in this thesis is \textbf{import}. We measure the dependency from the point of view of the library that acts as a client of a server library.

\paragraph{Criterion 3 - Granularity of the measure:}
In this criterion, there are two aspects to define. (1) The aggregation level of the measure, and (2) how the metric counts the connections. We first discuss the aggregation level. Briand et al. \cite{briand1999unified} define the following levels:

\begin{itemize}[noitemsep]
  \renewcommand\labelitemi{--}
  \item Attribute
  \item Method
  \item Class
  \item Set of classes
  \item System
\end{itemize}

\blankls
The goal is to measure the coupling between the set of classes of the client library and the server library classes. The measurement is done by aggregating the coupling of the more fine-grained levels \cite{briand1999unified}. For consistency with the terminology used in this thesis, we name this aggregation level \textbf{library level}.

Next, we define how the metric has to count connections. The options for counting connections defined by Briand et al. \cite{briand1999unified} are explained in Table \ref{table:counting-connections}. The options B), D), E), and F) are not useful for our use case. These options count the distinct items at the other end of the connection, not considering how many times those items are at the other end of the connection.

The two other options are A) and C), which count individual connections. The difference between A and C is the aggregation level at which the connections are counted. Option C) counts the connections as in A), but adding up the result for each class's method or attribute. Since the level of the domain of the metrics is not class but library, a new option for counting connections is defined, which would be option G. The definition is created following the same style as Briand et al.: \textbf{Add up the number of connections counted as in C) for each class of the library}. By following this method of aggregating the number of connections through aggregation levels, a fine-grained analysis is maintained for the aggregation level of the metrics.

\paragraph{Criterion 4 - Stability of the server:}
Briand et al. define stable classes as \textit{"Classes that are not subject to change in the project at hand"} \cite{briand1999unified}. Following this definition, the server of the connection has to be stable in this case. Therefore, we are going to count connections from non-stable elements to \textbf{stable servers}. According to the previously defined locus of impact, the non-stable classes are the stable classes' clients.

However, in this thesis, the differentiation between stable and unstable classes is not enough. The goal is to measure coupling only with classes that are part of other libraries. Therefore, the classes that belong to standard libraries and the programming language types, although stable, will not be considered by these metrics.

\paragraph{Criterion 5 - Direct and indirect coupling:}
To decide whether the metrics count or not indirect coupling, we need to distinguish two alternative scenarios in which we want to measure coupling: Direct dependencies and transitive dependencies. When measuring direct dependencies, we want to measure only direct coupling between the libraries, whereas, for transitive dependencies, it is necessary to measure indirect coupling. Hence, \textbf{both types of coupling} will be measured, with two different metrics for each selected type of connection: One for direct dependencies and another for transitive dependencies.

\paragraph{Criterion 6 - Inheritance:}
There are three aspects to decide within this criterion: how, if at all, does the metric distinguish between inheritance-based coupling and noninheritance-based coupling? If the metric counts method invocations, does it account for polymorphism? Finally, what defines if a method or an attribute is part of a class or not?

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{figures/specialcases.png}
\caption{Example of coupling special cases, based on example from Briand et al. \cite{briand1999unified}}
\label{fig:specialcases}
\end{center}
\end{figure}

In order to answer the first question, we focus on the method \texttt{mc} of \texttt{ClassB} in Figure \ref{fig:specialcases}. This method invokes \texttt{ma} of \texttt{ClassA}, inherited by \texttt{ClassB}.

This is known as \textit{inheritance-based} coupling and is sometimes considered as a special case of coupling.
When there is a change of an inherited method that a class uses, it requires the same maintenance as the method that is not inherited. Therefore, our metrics  \textbf{include inheritance-based coupling without distinction}.

In the case of the second question, polymorphism, we look at the methods of \texttt{ClassA}. This class contains an attribute of type \texttt{Class1}, which considering dynamic assignation of types could also be of type \texttt{Class2} or \texttt{Class3}.

We first analyze whether a call to a method of \texttt{Class1} would create coupling with \texttt{Class2} and \texttt{Class3}, and if it makes a difference when the method is overridden or not. The method \texttt{ma} invokes \texttt{m1}, which is not overridden by any of the descendants of \texttt{Class1}. When a change is made in \texttt{Class2} or \texttt{Class3} no change is required as the invoked method remains the same. In contrast, method \texttt{mb} calls \texttt{m2}, which is overridden in \texttt{Class2}. Here, the implementation of \texttt{m2} in \texttt{Class2} could be updated, and this may affect the way \texttt{ClassA} uses it, and therefore changes may be needed. Thus, it is necessary to \textbf{account for polymorphism}.

Lastly, we discuss about how to decide whether a method belongs to a class or not. We have two options: (1) a method belongs to the class that implements it (could be more than one since we account for polymorphism), or (2) a method belongs to the class that it is referenced from. An example of this can be found in the last two lines of the method \texttt{mc} of \texttt{ClassB} call method \texttt{m1} and \texttt{m2} on an object of type \texttt{Class2}. The difference is that \texttt{m1} is implemented in \texttt{Class1} and \texttt{m2} is overridden in \texttt{Class2}. From a maintenance perspective, when the method \texttt{m1} is updated in \texttt{Class1}, this probably requires update in \texttt{ClassB} as well. However, changes in \texttt{Class2} will not generate a need to update the method call \texttt{m1} in \texttt{ClassB}. When \texttt{m2} is updated in \texttt{Class1}, it will not make a difference for the call to \texttt{m2} in \texttt{ClassB} since it is not executing the implementation of \texttt{Class1}. Therefore, \textbf{a method call creates coupling with the class that contains the implementation}.

\paragraph{Summary}
Based on the criteria discussed above, we have four different definitions of coupling. Therefore, we create four metrics, each one measuring one type of coupling. The summary of the definitions of coupling created can be found in Table~\ref{table:metric-characteristics}.

\begin{table}[h]
    \begin{center}
    \begin{tabular}{|l|l|l|l|l|l|l|l|l|}
    \hline
    \rot{Metric} & \rot{Type of connection} & \rot{Locus of impact} & \rot{Domain of measure} & \rot{Counting connections   } & \rot{Direct/Indirect} & \rot{Inheritance} & \rot{Polymorphism} & \rot{Item belongs to class} \\ \hline
    \hline
    \#1   & 6 & Import & Library & Individual connections & Direct   & Both & Yes & Implemented \\\hline
    \#2   & 1 & Import & Library & Individual connections & Direct   & Both & Yes & Implemented \\\hline
    \hline
    \#3   & 6 & Import & Library & Individual connections & Indirect & Both & Yes & Implemented \\\hline
    \#4   & 1 & Import & Library & Individual connections & Indirect & Both & Yes & Implemented \\\hline
    \end{tabular}
    \end{center}
    \caption{Criteria of the set of metrics}
    \label{table:metric-characteristics}
\end{table}

\subsection{Metrics for direct dependencies}\label{section:defMetrics}
This section begins with a brief discussion in which the definition of coupling of the proposed metrics is compared with the existing metrics in the literature described in Section~\ref{section:bg-coupling}. Next, there is the formal definition of each our metrics. To end the section, the metrics' theoretical validation is done by proving the five properties of coupling metrics as defined by Briand et al. \cite{briand1996property}, for each one of the new metrics.

\subsubsection{Revisiting existing metrics}
Once we have defined the coupling that is going to be measured by each of the metrics (see Table \ref{table:metric-characteristics}), we can compare it with the existing coupling metrics, according to Table~\ref{table:coupling-metrics} in Section~\ref{section:bg-coupling}, to decide whether there are metrics measuring the same coupling we previously defined, or if it is necessary to create new metrics.

\paragraph{Metric \#1}
To compare the coupling defined for this first metric defined in Table~\ref{table:metric-characteristics} with the coupling measured by existing metrics, we focus on the ones that have the following characteristics:

\begin{itemize}
  \item Type of connection: method invocations (type 6 in Table \ref{table:types-connections})
  \item Locus of impact: import
  \item Direct or indirect coupling: direct
  \item Counting connections: count individual connections (option A or C in Table \ref{table:counting-connections}).
\end{itemize}

The metrics that share these characteristics are \textit{MPC}, the group \textit{ICP}, and the metrics \textit{AMMIC}, \textit{IFMMIC} and \textit{OMMIC}. However, \textit{MPC} does not consider polymorphic implementations of the called methods. \textit{IFMMIC} is a metric formulated specifically for C++ \cite{briand1997investigation} and therefore is not useful for our model. The metric \textit{IFMMIC} focuses on method invocations between classes with a \textit{friend} relationship, which does not exist in most languages. Furthermore, in case the language is C++ no distinction should be made between \textit{friend} and \textit{non-friend} classes.

From the group of metrics \textit{ICP}, the metric \textit{ICP}  considers both inheritance and non-inheritance coupling and therefore shares the definition of coupling with our metric. However, according to the definition of \textit{ICP}, the coupling created by each method call is weighted by the number of parameters of the called method. In this aspect, it differs from metric \#1 from Table~\ref{table:metric-characteristics}.

Finally, the metrics \textit{AMMIC} and \textit{OMMIC} use the same definition of coupling as metric \#1 except that \textit{AMMIC} counts the method invocations to ancestors and \textit{OMMIC} to other classes. Therefore, metric \#1 is the sum of \textit{AMMIC} and \textit{OMMIC}, but aggregated at the library level instead of the class level.

\paragraph{Metric \#2}
In the case of the second metric, which measures the coupling as defined in Table \ref{table:metric-characteristics}, we focus on the metrics with the following characteristics:

\begin{itemize}
  \item Type of connection: client class contains an attribute of type server class, aggregation coupling (type 1 in Table \ref{table:types-connections})
  \item Locus of impact: import
  \item Direct or indirect coupling: direct
  \item Counting connections: count individual connections (option A and C in Table \ref{table:counting-connections}, measure individual connections at the method and class level respectively)
\end{itemize}

According to Table \ref{table:coupling-metrics}, the metrics that share these characteristics are \textit{DAC}, and from the suite of metrics by Briand et al. \cite{briand1997investigation} the metrics \textit{IFCAIC}, \textit{ACAIC} and \textit{OCAIC}. However, \textit{IFCAIC} is an extension for C++ and will not be considered, for the same reasons for which we discarded \textit{IFMMIC} for metric \#1.

According to the definition of \textit{DAC}, it counts the number of attributes of a class that have any other class as type. Therefore, instead of calculating the coupling between two classes, it calculates a class's coupling with every other class. However, metric \#2 is used at the library level and calculates coupling between two libraries instead of the coupling of one library with all the others.

Finally, \textit{ACAIC} and \textit{OCAIC} consider aggregation coupling with ancestors and others respectively. Therefore, metric  \#2 is the sum of these two metrics, but aggregated to library aggregation level, since the metrics are designed for class level.

\subsubsection{Formal definitions}\label{subsec:metric-definition}

\paragraph{Metric \#1: Direct method invocation coupling (\texttt{MIC})}
The $\verb|MIC|$ metric measures the dependency between two libraries, one acting as a client ($L_c$) and the other as a server ($L_s$).
Based on the granularity of the measure criterion discussed in Section~\ref{subsect:defCoupling}, this metric is calculated for each of the classes implemented in $L_c$, and for each of the methods implemented $\verb|M|(L_c)$ in these classes. For each implemented method  $m_c \in \verb|M|(L_c)$, we count the number of individual invocations to a method of $L_s$, denoted $\verb|nII|(m_c,L_s)$. For each method invocation made by the methods implemented in $L_c$, we count only the ones implemented in stable classes (not implemented in $L_c$). The set of stable methods invoked is denoted $\verb|SIM|(m_c)$.

\begin{equation}
\label{eqn:mic}
\verb|MIC|(L_c, L_s) =\!\!\!\!\! \sum_{m_c \in \verb|M|(L_c)} \verb|nII|(m_c, L_s)
\end{equation}

According to the criterion inheritance, it is necessary to consider all the polymorphic implementations of the invoked method that are implemented in $L_s$. Therefore, we intersect the set of polymorphic implementations of an invoked method $\verb|PM|(m_s)$ with the set of methods $\verb|M|(L_s)$ implemented in $L_s$. Finally, to obtain the number of individual invocations, $\verb|nII|(m_c,L_s)$, we multiply the number of times a stable method ($m_s \in \verb|SIM|(m_c)$) has been invoked, $\verb|nI|(m_c, m_s)$ by the number of polymorphic implementations $\verb|nP|(m_s, L_s)$ of the method in $L_s$.

\begin{equation}
\label{eqn:mic-nii}
   \verb|nII|(m_c, L_s) = \sum_{m_s \in \verb|SIM|(m_c)} \verb|nI|(m_c, m_s)*\verb|nP|(m_s, L_s)
\end{equation}

\begin{equation}
\label{eqn:mic-np}
    \verb|nP|(m_s, L_s) = |\verb|PM|(m_s) \cap \verb|M|(L_s)|
\end{equation}

\paragraph{Metric \#2: Direct aggregation coupling (\texttt{AC})}

The $\verb|AC|$ metric counts the number of times when a class of $L_c$ has an attribute whose type is a class implemented in $L_s$. Therefore, the metric is calculated for each class implemented in $L_c$ ($c_c \in \verb|C|(L_c)$). We consider only those attributes types that are stable classes (not implemented in $L_c$) for each class $c_c$. The set of stable attribute types in a class $c$ is $\verb|SAT|(c_c)$.

To account for polymorphism (criterion \textit{inheritance}), we count all the descendants of the class that are implemented in $L_s$. Therefore, we intersect the set of the descendants of the class, $\verb|DC|(c_s)$, with the set of
classes implemented in $L_s$ ($\verb|C|(L_s)$). Finally, to count the  individual connections, we multiply the number of times a client class $c_c$ has an attribute of type the server class $c_s$ ($\verb|NA|(c_c, c_s)$) by the number of class descendants (class included) implemented in $L_s$ ($\verb|nDC|(c_s,L_s)$).

\begin{equation}
\label{eqn:ac}
  \verb|AC|(L_c,L_s) = \!\!\!\!\sum_{c_c \in \verb|C|(L_c)} \sum_{c_s \in \verb|SAT|(c_c)} \!\!\!\!\verb|NA|(c_c, c_s)*\verb|nDC|(c_s, L_s)
\end{equation}

\begin{equation}
\label{eqn:ac-ndc}
    \verb|nDC|(c_s, L_s) = |\verb|DC|(c_s) \cap \verb|C|(L_s)|
\end{equation}

\subsubsection{Theoretical validation}
The theoretical validation of the metrics consists of demonstrating the properties of the metrics. Theoretical validation is necessary since it proves that the metrics share properties with the attribute measured; in this case, the attribute is coupling. In particular, for coupling metrics, there are five properties defined by Briand et al. \cite{briand1996property}, which have been largely used by literature \cite{poshyvanyk2006conceptual, allen1999measuring, zhao2004measuring}. First, we describe each of the properties, and then, we prove them for each of the metrics.

\begin{enumerate}
  \item \textbf{Nonnegativity:} The value of the coupling metrics should never be negative.
  \item \textbf{Null value:} The value of the coupling is expected to be zero if there is no relationship from the client library to the server library.
  \item \textbf{Monotonicity:} It is expected that if more relationships are added from the client library to the server library, the metric value does not decrease.
  \item \textbf{Merging of classes:} If two classes of the client library are merged, the total coupling between the client library and the server library should not increase.
  \item \textbf{Merging of unconnected classes:} When two classes of the client library, which do not share usage of the server library, are merged, the total coupling between the client library and the server library should remain equal.
\end{enumerate}

To describe the properties in greater detail, we use $\verb|Coupling|(L_c, L_s)$ to refer to both $\verb|AC|$ and $\verb|MIC|$, and $\verb|R|(L_c, L_s)$ to refer to the set of relationships between $L_c$ and $L_s$, $\verb|Coupling|(L_c, L_s)$ uses $\verb|R|(L_c, L_s)$ to evaluate the coupling between the two elements, but the way it is used differs per metric. To refer to the relations between a class of the client library, $c_c$, and the server library, we use $\verb|R|(c_c, L_s)$, and the coupling between the class and the server library is $\verb|Coupling|(c_c, L_s)$. The description of the properties is based on the description done by Briand et al. \cite{briand1996property}, which was meant for coupling metrics that measure the coupling within an element, or between an element and all the other elements. Therefore, the properties' description has been adapted for metrics that measure coupling between two different elements. Also, since all the newly introduced metrics measure import coupling, the properties' definitions are focused on this locus of impact.

\paragraph{Nonnegativity}

Let $L_c$ be a client library and $L_s$ be a server library. The coupling between the two libraries is non-negative, $\verb|Coupling|(L_c, L_s) \ge 0$.

\paragraph{Null value}
Coupling is expected to be null (zero) when there is no import relationship between the client and the server libraries.

Let $L_c$ be a client library and $L_s$ be a server library. The coupling between the two libraries is null if the set of import relationships from $L_c$ to $L_s$, $\verb|R|(L_c, L_s)$, is empty. Therefore, $\verb|R|(L_c, L_s) = \emptyset \implies \verb|Coupling|(L_c, L_s) = 0$.

\paragraph{Monotonicity}
Considering the definition of coupling, it is expected that when more relationships are added between the libraries, coupling does not decrease.

Let $L_c$ be a client library, $L_s$ be a server library, and $c \in L_c$ be a class in $L_c$. We modify class $c$ to form a new class $c'$ which is identical to $c$ except that $\verb|R|(L_c, L_s) \subseteq \verb|R|(L_c', L_s)$. For example, some method invocations have been added from $c$ to classes implemented in $L_s$. Let $L_c'$ be a library identical to $L_c$ but in which $c$ has been replaced by $c'$. Then, $\verb|Coupling|(L_c, L_s) \le \verb|Coupling|(L_c', L_s)$.

\paragraph{Merging of classes}
The original definition of the property is created for metrics that measure coupling within a system, and therefore it is necessary to reformulate it. It is expected that if two classes of a system are merged, the system's coupling does not increase. If two classes are merged, the coupling between the two classes is subtracted from the system's total coupling.

When considering the coupling between a client library and a server library, if two client library classes are merged, the two libraries' coupling would not increase. It could decrease, depending on how the refactoring is performed. If the classes share usage of the server library, one of the usages may be removed.

Therefore, let $L_c$ be a client library, $L_s$ be a server library, and $c_1, c_2 \in L_c$ two classes in $L_c$. Let $c'$ be the class that results from merging  $c_1$ and $c_2$, and $L_c'$ be the library resulting from $L_c$ when $c_1$ and $c_2$ have been replaced by $c'$. Then, $\verb|Coupling|(c_1, L_s) + \verb|Coupling|(c_2, L_s) \ge \verb|Coupling|(c', L_s)$ and $\verb|Coupling|(L_c, L_s) \ge \verb|Coupling|(L_c', L_s)$.

\paragraph{Merging of unconnected classes}
This property is a variation of the previous one, and it has to be adapted to the use case of this thesis. It is expected that the system's coupling will stay the same if two classes of a system, which have no relationship, are merged. This is because the class that results in the merging will have the same number of relationships with other classes as the original two.

When measuring the coupling between a client library and a server library, the two unconnected classes are not using the server library in the same way. Therefore, none of the relationships with the server library can be merged when merging the two classes, and the coupling with the server library stays the same.

Let $L_c$ be a client library, $L_s$ a server library, and $c_1, c_2 \in L_c$ two classes from $L_c$ which do not share the same relationship with $L_s$. Let $c'$ be the class that is the union of  $c_1$ and $c_2$, and $L_c'$ be the library identical to $L_c$ but in which $c_1$ and $c_2$ have been replaced by $c'$. If there are no relationships between $c_1$ and $c_2$, then, $\verb|Coupling|(c_1, L_s) + \verb|Coupling|(c_2, L_s) = \verb|Coupling|(c', L_s)$ and $\verb|Coupling|(L_c, L_s) = \verb|Coupling|(L_c', L_s)$.

\subsubsection{Theoretical validation: MIC}

\paragraph{Nonnegativity}
If we assume that the metric $\verb|MIC|$ does not fulfill the property Nonnegativity, there should be a client library $L_s$ and a server library $L_c$ such that $\verb|MIC|(L_c, L_s) < 0$.
According to the equation \ref{eqn:mic}, this means that exists at least one client method $m_c \in \verb|M|(L_c)$ such that $\verb|nII|(m_c, L_c) < 0$. Following the equation of $\verb|nII|$ \ref{eqn:mic-nii}, this opens two possibilities.

First, that there is a server method $m_s \in \verb|SIM|(m_c)$ such that $\verb|nI|(m_c, m_s) < 0$. However, $m_s$ is a method out of the set $\verb|SIM|(m_c)$ which is the set of stable methods invoked by $m_c$, which means that $\verb|nI|(m_c, m_s) > 0$ for all $m_s \in \verb|SIM|(m_c)$, therefore it is a contradiction.

The other option is that there is a method $m_s \in \verb|SIM|(m_c)$ such that $\verb|nP|(m_s, L_s) < 0$. $\verb|nP|(m_s, L_s)$, according to the equation \ref{eqn:mic-np}, corresponds to the cardinality of the intersection between the set $\verb|PM|(m_s)$ and $\verb|M|(L_s)$. Therefore, the cardinality of the intersection has to be less than zero. However, the cardinality of the intersection is by definition greater or equal to zero. This constitutes a contradiction.

Therefore, the initial assumption is not true, and \textit{Nonnegativity} holds for the metric $\verb|MIC|$.

\paragraph{Null value}
Assuming there is no null value for metric $\verb|MIC|$, there is a client library $L_c$ and a server library $L_s$ such that $\verb|R|(L_c, L_s) = \emptyset$, and $\verb|MIC|(L_c, L_s)	\neq 0$. As non-negativity holds, we have that $\verb|MIC|(L_c, L_s) \ge 0$. Therefore, $\verb|MIC|(L_c, L_s) > 0$. Hence, following equation \ref{eqn:mic} there is a client method $m_c \in M(L_c)$ such that $\verb|nII|(m_c, L_s) > 0$.

Thus, according to equation \ref{eqn:mic-nii}, there is a server method $m_s \in \verb|SIM|(m_c)$, such that $\verb|nI|(m_c, m_s) > 0$ and $\verb|nP|(m_s, L_s) > 0$. Therefore, the method $m_s$ is called at least one time by the method $m_c$ from the client library $L_c$, and at the same time is implemented by the server library $L_s$, which means that there is a relationship between $L_c$ and $L_s$, which contradicts the original assumption that $\verb|R|(L_c, L_s) = 0$.

Consequently, there is a \textit{null value} for metric $\verb|MIC|$.

\paragraph{Monotonicity}
Let $L_c$ be a client library that contains class $c_c$, and let $c_c'$ be a class resulting from adding relationships with the server library $L_s$ to the class $c_c$. Then, $\verb|R|(c_c, L_s) \subseteq \verb|R|(c_c', L_s)$. Let $L_c'$ be a client library identical to $L_c$ but in which the class $c_c$ has been replaced by $c_c'$. Therefore, $\verb|R|(L_c, L_s) \subseteq \verb|R|(L_c', L_s)$.

Let's assume that the $\verb|MIC|$ metric does not fulfill the property monotonicity, this would mean that $\verb|MIC|(L_c, L_s) > \verb|MIC|(L_c', L_s)$. Since the only difference between $L_c$ and $L_c'$ is the substitution of $c_c$ by $c_c'$, then $\sum_{m_c \in \verb|M|(c_c)} \verb|nII|(m_c, L_s) > \sum_{m_c' \in \verb|M|(c_c')} \verb|nII|(m_c', L_s)$ (see equation \ref{eqn:mic}). Therefore, the methods of class $c_c$ have more individual invocations to $L_s$ than the methods from class $c_c'$. This contradicts the initial assumption that $\verb|R|(c_c, L_s) \subseteq \verb|R|(c_c', L_s)$.

Therefore, \textit{Monotonicity} holds for the metric $\verb|MIC|$.

\paragraph{Merging of classes}
Let $L_c$ be a client library that includes the classes $c_1$ and $c_2$. Let $c'$ be a class such that $c_1 + c_2 = c'$ and $L_c'$ be a client library identical to $L_c$ but where $c_1$ and $c_2$ have been replaced by $c'$. If we assume that the property merging of classes does not hold for metric $\verb|MIC|$, it would mean that $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$ and at the same time $\verb|MIC|(L_c, L_s) > \verb|MIC|(L_c', L_s)$.

Therefore, there is a method $m_c$ which is implemented in $c_1$ or $c_2$ such that contains a call to a method $m_s$ which does not exist in any of the methods implemented in $c'$. This is a contradition with the initial affirmation $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$. Therefore, the property \textit{Merging of classes} holds for metric $\verb|MIC|$.

\paragraph{Merging of unconnected classes}
Let $L_c$ be a client library and $L_s$ be a server library. Let $c_1$ and $c_2$ be classes implemented in $L_c$, such that $\verb|R|(c_1, L_s) \cap \verb|R|(c_2, L_s) = \emptyset$. Let $c'$ be a class such that $c_1 + c_2 = c'$. Therefore, $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$. Let $L_c'$ be a client library identical to $L_c$ but in which $c_1$ and $c_2$ have been replaced by $c'$. We assume that the metric $\verb|MIC|$ does not fulfill this property.

Therefore, $\verb|MIC|(L_c, L_s) \neq \verb|MIC|(L_c', L_s)$. According to property \textit{Merging of classes}, $\verb|MIC|(L_c, L_s)$ cannot be less than $\verb|MIC|(L_c', L_s)$. Thus, $\verb|MIC|(L_c, L_s) > \verb|MIC|(L_c', L_s)$. This means that there is a $m_c$ implemented in $c_1$ or $c_2$ that contains an invocation to a method $m_s$ implemented in $L_s$, which is not included in $c'$. This contradicts that $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$.

Therefore, property \textit{Merging of unconnected classes} holds for metric $\verb|MIC|$.

\subsubsection{Theoretical validation: AC}

\paragraph{Nonnegativity}
Supose that the metric $\verb|AC|$ does not have the nonnegativity property. Thus, there is a client library $L_c$ and a server library $L_s$ such that $\verb|AC|(L_c, L_s) < 0$. Then, according to equation \ref{eqn:ac} there is a client class $c_c \in \verb|C|(L_c)$ and a server class $c_s \in \verb|SAT|(c_c)$ such that either $\verb|NA|(c_c, c_s)$ or $\verb|nDC|(c_s, L_s)$ have a negative value.

Let's assume that $\verb|NA|(c_c, c_s) < 0$. This means that the $c_s$ is a class that is included in the set of stable classes declared as fields in $c_c$ ($c_s \in \verb|SAT|(c_c)$) and, at the same time is declared a negative number of times, which is a contradiction.

Therefore, $\verb|nDC|(c_s, L_s)$ has to be negative. According to equation \ref{eqn:ac-ndc}, $\verb|nDC|(c_s, L_s)$ corresponds to the cardinality of the intersection between two sets. Even if the two sets do not share any element, by definition, the intersection will be the empty set, and the cardinality will be zero. Hence, $\verb|nDC|(c_s, L_s)$ cannot have a negative value, and the initial assumption is false.

In conclusion, \textit{Nonnegativity} holds for the metric $\verb|AC|$.

\paragraph{Null value}
If we assume that property null value does not hold for metric $\verb|AC|$, there has to be a client library $L_c$ and a server library $L_s$ such that have no relationship ($\verb|R|(L_c, L_s) = 0$) and $\verb|AC|(L_c, L_s)	\neq 0$. Since $\verb|AC|$ has the property \textit{Nonnegativity}, the result cannot be negative, which means that $\verb|AC|(L_c, L_s) > 0$. Hence, following equation \ref{eqn:ac}, there is a client class $c_c \in \verb|C|(L_c)$ and a server class $c_s \in \verb|SAT|(c_c)$ such that $\verb|NA|(c_c, c_s) > 0$ and $\verb|nDC|(c_s, L_s) > 0$. This means that the class $c_s$ is at the same time declared at least once by the client class $c_c$ ($\verb|NA|(c_c, c_s) > 0$) and implemented in the server library $L_s$. However, this would create a relationship between $L_c$ and $L_s$, which contradicts the initial assumption.

 Therefore, the property \textit{Null value} holds for metric $\verb|AC|$.

\paragraph{Monotonicity}
Let $L_c$ be a client library that contains class $c_c$, and let $c_c'$ be a class identical to $c_c$ but more relationships with the server library $L_s$. Then, $\verb|R|(c_c, L_s) \subseteq \verb|R|(c_c', L_s)$. Let $L_c'$ be a client library identical to $L_c$ but in which the class $c_c$ has been replaced by $c_c'$. Therefore, $\verb|R|(L_c, L_s) \subseteq \verb|R|(L_c', L_s)$.

If we assume that the metric $\verb|AC|$ does not fulfill this property, means that $\verb|AC|(L_c, L_s) > \verb|AC|(L_c', L_s)$. The only difference between these two calculations is the result of the calculation for $c_c$ and $c_c'$. Therefore, $\sum_{c_s \in \verb|SAT|(c_c)} \verb|NA|(c_c, c_s) * \verb|nDC|(c_s, L_s) > \sum_{c_s \in \verb|SAT|(c_c')} \verb|NA|(c_c', c_s) * \verb|nDC|(c_s, L_s)$, see equation \ref{eqn:ac}.

This means that there is a server class $c_s \in \verb|SAT|(c_c)$, that is implemented in $L_s$ ($\verb|nDC|(c_s, L_s) > 0$) such that $\verb|NA|(c_c, c_s) > \verb|NA|(c_c', c_s)$. This contradicts the original assumption that $c_c'$ is constructed from $c_c$ but with additional relationships with $L_s$. $\verb|NA|(c_c, c_s)$ will only be greater than $\verb|NA|(c_c', c_s)$ if there is an attribute of type $c_s$ in $c_c$ (which is a relationship between $c_c$ and $L_s$) that does not exist in $c_c'$.

Therefore, \textit{Monotonicity} holds for the metric $\verb|AC|$.

\paragraph{Merging of classes}
Let $L_c$ be a client library that includes the classes $c_1$ and $c_2$. Let $c'$ be a class such that $c_1 + c_2 = c'$ and $L_c'$ be a client library identical to $L_c$ but where $c_1$ and $c_2$ have been replaced by $c'$. We assume that the property merging of classes does not hold for metric $\verb|AC|$. Therefore, $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$ and, also $\verb|AC|(L_c, L_s) > \verb|AC|(L_c', L_s)$.

Thus, either $c_1$ or $c_2$ contain an attribute of type $c_s$, such that $c_s$ is implemented in $L_s$ and it is not included $c'$. This creates a contradition with the initial affirmation $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$, since the declaration of an attribute of type $c_s$ is included in $\verb|R|(c_1, L_s)$ or $\verb|R|(c_2, L_s)$. Therefore, \textit{Merging of classes} holds for metric $\verb|AC|$.

\paragraph{Merging of unconnected classes}
Let $L_c$ be a client library and $L_s$ be a server library. Let $c_1$ and $c_2$ be classes implemented in $L_c$, such that $\verb|R|(c_1, L_s) \cap \verb|R|(c_2, L_s) = \emptyset$. Let $c'$ be a class such that $c_1 + c_2 = c'$. Therefore, $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$. Let $L_c'$ be a client library identical to $L_c$ but in which $c_1$ and $c_2$ have been replaced by $c'$. We assume that the metric $\verb|AC|$ does not fulfill property \textit{Merging of unconnected classes}.

Therefore, $\verb|AC|(L_c, L_s) \neq \verb|AC|(L_c', L_s)$. According to property \textit{Merging of classes}, it cannot happen that $\verb|AC|(L_c, L_s) < \verb|AC|(L_c', L_s)$. Therefore, $\verb|AC|(L_c, L_s) > \verb|AC|(L_c', L_s)$. The only way this is if there is an attribute of type $c_s$ declared in $c_1$ or $c_2$ and implemented in $L_s$, such that is not included in $c'$. This creates a contradition with the initial affirmation that $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$.

Therefore, metric $\verb|AC|$ fulfills \textit{Merging of unconnected classes}.

\subsection{Metrics for transitive dependencies}\label{subsect:defMetricsTransitive}
In this section, the metrics to measure transitive dependencies are described. First, the characteristics of the metrics, according to the criteria previously discussed and summarized in Table \ref{table:metric-characteristics}, are compared to the existing metrics described in section \ref{section:bg-coupling}. Next, some concepts involved in the formulation of the transitive metrics are explained. Then, there is a formal definition of the two metrics for transitive dependencies. Finally, the five properties of coupling metrics are demonstrated.

\subsubsection{Revisiting existing metrics}
In the set of metrics reviewed by Briand et al. \cite{briand1999unified}, there is only one metric that does count indirect coupling, $RFC'$ (see Table \ref{table:coupling-metrics}). This metric also counts inheritance-based coupling, and it is focused on the client element, just as the metrics \#3 and \#4 defined in Table \ref{table:metric-characteristics}. However, $RFC'$ is calculated at the class aggregation level, whereas the metrics for this work are calculated at the library level. Furthermore, the strategy to count connections is E, which means that it counts the number of elements with which the class has a connection, not how many connections.

Therefore, both metrics \#3 and \#4 are entirely unrelated to those reviewed by Briand et al. \cite{briand1999unified}.

\subsubsection{Concepts related to transitive dependencies}
Other factors have to be taken into account to define the coupling for transitive metrics, which are not needed for the direct metrics.

\paragraph{Reachability}
To measure the transitive dependencies, only those methods or classes of the transitive dependencies that are \textit{reachable} from the analysed client library are considered. For a given call-graph, a method is reachable if there is a path from the client library to the method \cite{fasten2020D3.2}. For example, in Figure \ref{fig:reachability}, there is no path from \texttt{Lib1} (the client library) to the method \texttt{Method10}. Therefore, \texttt{Method10} is not reachable form \texttt{Lib1} and the call from \texttt{Method6} to \texttt{Method10} will not be considered when measuring the transitive dependency between \texttt{Lib1} and \texttt{Lib3}, in the case of method invocation coupling.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{figures/Reachability.png}
\caption{Reachability example}
\label{fig:reachability}
\end{center}
\end{figure}

\paragraph{Propagation Factor}
The propagation represents how the impact of a change can spread across dependencies \cite{fasten2019survey}. In Figure \ref{fig:reachability}, a change in \texttt{Method3} would affect directly the client  library (\texttt{Lib1}). However, a change in \texttt{Method7}, affects first \texttt{Method3}, and then it can spread to \texttt{Method1}, in case it is not mitigated in \texttt{Method3}. This possible mitigation is accounted for by the \textit{Propagation Factor}.

\subsubsection{Formal definition}

\paragraph{Metric \#3: Transitive method invocation coupling (\texttt{TMIC})}
If we look at how the metric $\verb|MIC|$ is calculated, it could be summarized as follows: find all the methods in $L_s$ that are reachable from $L_c$. Then, for each one, count how many method calls exist in $L_c$ that reach this method, and sum up the results. The main difference between $\verb|MIC|$ and $\verb|TMIC|$ is that the calls in $L_c$ will not directly execute a reachable method of $L_s$. The execution of a method in $L_s$ is indirect since $L_s$ is not a direct dependency of $L_c$.

Therefore, it is necessary to take into account the distance between $L_c$ and $L_s$. In addition, it could happen that $L_s$ is reachable from $L_c$ at different distances. For instance, if $L_s$ appeared twice in the dependency tree of $L_c$, this is is the case in Figure \ref{fig:dependency-tree} if we take \texttt{Lib1} as $L_c$ and \texttt{Lib4} as $L_s$.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.4\textwidth]{figures/Thesis-DependencyTree.png}
\caption{Example dependency tree}
\label{fig:dependency-tree}
\end{center}
\end{figure}

Therefore, the coupling will be measured for a certain $\verb|distance|$, denoted $\verb|TMICD|(L_c,L_s, \verb|distance|)$.
The value of the metric $\verb|TMIC|(L_c,L_s)$, will be measured as follows. For each $\verb|distance|$ at which there is coupling between $L_c$ and $L_s$, sum up the coupling measured by $\verb|TMICD|(L_c,L_s, \verb|distance|)$, multiplied by a propagation factor ($\verb|PF|$) to the power of the $\verb|distance| - 1$, where $\verb|PF| \in (0,1)$. We have designed the formula by taking the propagation factor to the power of $\verb|distance| - 1$, because this way, the coupling of the direct dependencies ($\verb|distance| = 1$) is not mitigated. Also, then when $\verb|distance| = 2$, which corresponds to the first level of transitivity, the coupling is mitigated only once.

\begin{equation}
\label{eqn:tmic}
  \verb|TMIC|(L_c,L_s) = \sum_{\verb|distance|} \verb|TMICD|(L_c,L_s, \verb|distance|) * \verb|PF|^{\verb|distance| - 1}
\end{equation}

The transitive coupling between two libraries at a certain distance $\verb|TMICD|(L_c, L_s, \verb|distance|)$ is calculated in the following manner. For each method from $L_s$ that is reachable from $L_c$ throught method calls at $\verb|distance|$ ($rm \in \verb|RM|(L_c,L_s,\verb|distance|)$), we count the number of method invocations in $L_c$ from which $rm$ is reachable, $\verb|nIR|(rm, L_c)$. The number of method invocations is multiplied by the number of polymorphic implementations of $rm$ in $L_s$ ($\verb|nDC|(rm, L_s)$).

\begin{equation}
\label{eqn:imic}
  \verb|TMICD|(L_c,L_s,\verb|distance|) = \sum_{rm \in \verb|RM|(L_c,L_s,\verb|distance|)} \verb|nIR|(rm,L_c) * \verb|nP|(rm, L_s)
\end{equation}

\paragraph{Metric \#4: Transitive aggregation coupling (\texttt{TAC})}
To calculate $\verb|TAC|$, just as in the case of $\verb|TMIC|$, the $\verb|distance|$ between $L_c$ and $L_s$ should be considered. Therefore, for each $\verb|distance|$, we take the number measured by $\verb|TACD|(L_c,L_s, \verb|distance|)$, and multiply it by a propagation factor $\verb|PF|$ to the power of the $\verb|distance| - 1$.

\begin{equation}
\label{eqn:tac}
  \verb|TAC|(L_c,L_s) = \sum_{\verb|distance|} \verb|TACD|(L_c,L_s, \verb|distance|) * \verb|PF|^{\verb|distance| - 1}
\end{equation}

The transitive aggregation coupling per distance ($\verb|TACD|(L_c, L_s, \verb|distance|)$), is calculated in the following way. For each class of $L_s$ that is reachable from $L_c$ through field declarations at $\verb|distance|$ ($rc \in \verb|RC|(L_c,L_s,\verb|distance|)$), count all the field declarations from which it is reachable ($\verb|nFR|(rc,L_c)$), and multiply it by the number of descendants of the reachable class ($\verb|nDC|(rm, L_s)$).

\begin{equation}
\label{eqn:iac}
  \verb|TACD|(L_c,L_s,\verb|distance|) = \sum_{rc \in \verb|RC|(L_c,L_s,\verb|distance|)} \verb|nFR|(rc,L_c) * \verb|nDC|(rm, L_s)
\end{equation}

\subsubsection{Theoretical validation: TMIC}

\paragraph{Nonnegativity}
Assume that nonnegativity does not hold for metric $\verb|TMIC|$. Then, there exists a client library $L_c$, and a server library $L_s$ such that $\verb|TMIC|(L_c, L_s) < 0$. According to equation \ref{eqn:tmic}, there is a $\verb|distance|$ for which either $\verb|TMICD|(L_c,L_s, \verb|distance|) < 0$ or $\verb|PF|^{\verb|distance - 1|} < 0$. Since $\verb|distance|$ is a positive integer, and $\verb|PF| \in (0,1)$, the second option is not possible.

Let us assume that $\verb|TMICD|(L_c,L_s, \verb|distance|) < 0$. Looking at the equation \ref{eqn:imic}, we see that there has to be at least one method, $rm$, from $L_s$ and reachable from $L_c$ at a certain distance ($rm \in \verb|RM|(L_c,L_s,\verb|distance|)$), such that $\verb|nIR|(rm,L_c) < 0$ or $\verb|nP|(rm, L_s) < 0$. Since $\verb|nP|(rm, L_s)$ corresponds to the number of polymorphic implementations of $rm$ in $L_s$, and we know that $rm$ belongs to $L_s$, then $\verb|nP|(rm, L_s) \geq 1$. Finally, for $\verb|nIR|(rm,L_c) < 0$ to be true, there should be less than zero method invocations in $L_c$ from which $rm$ is reachable. However, since $rm \in \verb|RM|(L_c,L_s,\verb|distance|)$, and $\verb|RM|(L_c,L_s,\verb|distance|)$ corresponds to the set of methods from $L_s$ that are reachable from $L_c$, we have that $\verb|nIR|(rm,L_c) \geq 1$, which constitutes a contradition.

Therefore, the metric $\verb|TMIC|$ fulfills the property \textit{Nonnegativity}.

\paragraph{Null value}
Assuming that $\verb|TMIC|$ does not fulfill property \textit{Null value}, there exists a client library $L_c$, and a server library $L_s$ such that $\verb|R|(L_c, L_s) = \emptyset$ and $\verb|TMIC|(L_c, L_s) \neq 0$.

For $\verb|TMIC|(L_c, L_s) \neq 0$ to be true, according to equation \ref{eqn:imic}, there has to be a method $rm$ such that  $rm \in \verb|RM|(L_c,L_s,\verb|distance|)$. However, that would mean that $rm$ belongs to $L_s$, and is reachable from $L_c$, which constitutes a relation between $L_c$ and $L_s$, and contradicts $\verb|R|(L_c, L_s) = \emptyset$.

Hence, the property \textit{null value} holds for metric $\verb|TMIC|$ .

\paragraph{Monotonicity}
Let $L_c$ be a client library containing class $c_c$, and $c_c'$ be a class resulting from adding relationships with the server library $L_s$ to class $c_c$. Then, $\verb|R|(c_c, L_s) \subseteq \verb|R|(c_c', L_s)$. Let $L_c'$ be a client library resulting from replacing class $c_c$ by $c_c'$ in $L_c$. Therefore, $\verb|R|(L_c, L_s) \subseteq \verb|R|(L_c', L_s)$.

If we assume that $\verb|TMIC|$ does not fulfill property \textit{Monotonicity}, it would be true that $\verb|TMIC|(L_c, L_s) > \verb|TMIC|(L_c', L_s)$. Therefore, for a certain distance, we have that $\verb|TMICD|(L_c,L_s,\verb|distance|) > \verb|TMICD|(L_c',L_s,\verb|distance|)$, according to equation \ref{eqn:tmic}. According to the equation \ref{eqn:imic}, this opens two possibilities.

First, we have that $|\verb|RM|(L_c,L_s,\verb|distance|)| > |\verb|RM|(L_c',L_s,\verb|distance|)|$, which means that there are more methods from $L_s$ reachable from $L_c$ than from $L_c'$. This is not possible since, the only difference between $L_c$ and $L_c'$ is the substitution of class $c_c$ by class $c_c'$, which only adds relationships with $L_s$.

The second option is that for a certain $rm \in \verb|RM|(L_c,L_s,\verb|distance|)$, and therefore also $rm \in \verb|RM|(L_c',L_s,\verb|distance|)$, such that   $\verb|nIR|(rm,L_c) > \verb|nIR|(rm,L_c')$. However, that means that in $L_c$ there are more method invocations that reach $rm$, than in $L_c'$. As discussed earlier, this constitutes a contradicion with the way $L_c'$ is created.

Therefore, property 3 \textit{Monotonicity} holds for $\verb|TMIC|$.

\paragraph{Merging of classes}
Let $L_c$ be a client library that includes the classes $c_1$ and $c_2$. Let $c'$ be a class such that $c_1 + c_2 = c'$ and $L_c'$ be a client library resulting from replacing $c_1$ and $c_2$ by $c'$ in $L_c$. If we assume that the property merging of classes does not hold for $\verb|TMIC|$, then $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$ and $\verb|TMIC|(L_c, L_s) > \verb|TMIC|(L_c', L_s)$.

Since the only difference between $L_c$ and $L_c'$ is the replacement of $c_1$ and $c_2$ by $c'$, there has to be a method invocation from $c_1$ or $c_2$ to a method $rm \in \verb|RM|(L_c,L_s,\verb|distance|)$, which is not included in $c'$. However, the method invocation has to be a relation included in $\verb|R|(c_1, L_s)$ or $\verb|R|(c_2, L_s)$, and we have that $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$. Therefore it is a contradiction.

Hence, the property \textit{Merging of classes} holds for $\verb|TMIC|$.

\paragraph{Merging of unconnected classes}
Let $L_c$ be a client library and $L_s$ be a server library. Let $c_1$ and $c_2$ be classes implemented in $L_c$, such that $\verb|R|(c_1, L_s) \cap \verb|R|(c_2, L_s) = \emptyset$. Let $c'$ be a class such that $c_1 + c_2 = c'$. Therefore, $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$. Let $L_c'$ be a client library identical to $L_c$ but in which $c_1$ and $c_2$ have been replaced by $c'$. We assume that the metric $\verb|TMIC|$ does not fulfill this property.

Therefore, $\verb|TMIC|(L_c, L_s) \neq \verb|TMIC|(L_c', L_s)$. According to property \textit{Merging of classes}, $\verb|TMIC|(L_c, L_s) \geq \verb|TMIC|(L_c', L_s)$. Hence, $\verb|TMIC|(L_c, L_s) > \verb|TMIC|(L_c', L_s)$.

Then, there is a method invocation is $c_1$ or $c_2$ which is not included in $c$, which contradicts that $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$.

We conclude that $\verb|TMIC|$ fulfills property \textit{Merging of unconnected classes}.

\subsubsection{Theoretical validation: TAC}

\paragraph{Nonnegativity}
Assuming that nonnegativity does not hold for metric $\verb|TAC|$, there exists a client library $L_c$, and a server library $L_s$ such that $\verb|TAC|(L_c, L_s) < 0$. In line with equation \ref{eqn:tac}, there is a $\verb|distance|$ for which two things can happen. First, $\verb|PF|^{\verb|distance| - 1} < 0$. However, since $\verb|distance|$ is a positive integer, and $\verb|PF| \in (0,1)$, this is not possible.

The second option is that $\verb|TACD|(L_c,L_s, \verb|distance|) < 0$. Looking at the equation \ref{eqn:iac}, we see that there has to be at least one class, $rc \in \verb|RC|(L_c,L_s,\verb|distance|)$, that belongs to $L_s$ and is reachable from $L_c$, such that $\verb|nFR|(rc,L_c) < 0$ or $\verb|nDC|(rm, L_s) < 0$. $\verb|nDC|(rm, L_s)$ is the number of descendants of $rc$ in $L_s$. As we know that $rc$ belongs to $L_s$, we have that $\verb|nDC|(rm, L_s) \geq 1$.

Finally, if $\verb|nFR|(rc,L_c) < 0$ is true, there are less than zero field declarations in $L_c$ from which $rc$ is reachable. However, since $rc \in \verb|RC|(L_c,L_s,\verb|distance|)$, and $\verb|RC|(L_c,L_s,\verb|distance|)$ corresponds to the set of classes from $L_s$ that are reachable from $L_c$ through field declarations, we have that $\verb|nFR|(rc,L_c) \geq 1$, which constitutes a contradition.

Therefore, the property \textit{Nonnegativity} holds for metric $\verb|TAC|$.

\paragraph{Null value}
Let us assume that $\verb|TAC|$ does not fulfill property \textit{Null value}. Therefore, there exists a client library $L_c$, and a server library $L_s$ such that $\verb|R|(L_c, L_s) = \emptyset$ and $\verb|TAC|(L_c, L_s) \neq 0$.

If $\verb|TAC|(L_c, L_s) \neq 0$ then, as stated in equation \ref{eqn:iac}, there has to be a class $rc$ such that  $rc \in \verb|RC|(L_c,L_s,\verb|distance|)$. However, if $rc \in \verb|RC|(L_c,L_s,\verb|distance|)$, then $rc$ belongs to $L_s$, and is reachable from $L_c$. This creates a relation between $L_c$ and $L_s$, and therefore contradicts $\verb|R|(L_c, L_s) = \emptyset$.

In conclusion, the property \textit{Null value} holds for metric $\verb|TAC|$.

\paragraph{Monotonicity}
Assuming that property \textit{Monotonicity} does not hold for metric $\verb|TAC|$, let $L_c$ be a client library containing class $c_c$, and $L_s$ be a server library. Also, let $c_c'$ be the resulting class of adding new relationships with $L_s$ to class $c_c$. Then, $\verb|R|(c_c, L_s) \subseteq \verb|R|(c_c', L_s)$. Let $L_c'$ be the client library resulting from replacing class $c_c$ by $c_c'$ in $L_c$. Therefore, $\verb|R|(L_c, L_s) \subseteq \verb|R|(L_c', L_s)$.

Since $\verb|TAC|$ does not fulfill property \textit{Monotonicity}, we have that $\verb|TAC|(L_c, L_s) > \verb|TAC|(L_c', L_s)$. Hence, for a certain distance, it is true that $\verb|TACD|(L_c,L_s,\verb|distance|) > \verb|TACD|(L_c',L_s,\verb|distance|)$, according to equation \ref{eqn:tac}. As equation \ref{eqn:iac} indicates, this can be true in two cases.

The first option is $|\verb|RC|(L_c,L_s,\verb|distance|)| > |\verb|RC|(L_c',L_s,\verb|distance|)|$.
In other words, there are more classes from $L_s$ reachable from $L_c$ than from $L_c'$. Since the only difference between $L_c$ and $L_c'$ is the replacement of class $c_c$ by $c_c'$, and according to the definition of class $c_c'$, this is not possible.

Therefore, the last option is that there is a class $rc \in \verb|RC|(L_c,L_s,\verb|distance|) \land rc \in \verb|RC|(L_c',L_s,\verb|distance|)$, such that   $\verb|nFR|(rc,L_c) > \verb|nFR|(rc,L_c')$. This implies that the number of field declarations that reach $rc$ in $L_c$is greater than in $L_c'$, which is a contradicion with the definition of $L_c'$.

Therefore, property \textit{Monotonicity} holds for $\verb|TAC|$.

\paragraph{Merging of classes}
Let $L_c$ be a client library, and let classes $c_1$ and $c_2$ be classes implemented in $L_c$. Also, let $c'$, created as follows $c' = c_1 + c_2$, and $L_c'$ be a client library based on $L_c$ in which $c_1$ and $c_2$ have been replaced by $c'$. Assuming \textit{merging of classes} does not hold for $\verb|TAC|$, we have that $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s) \land \verb|TAC|(L_c, L_s) > \verb|TAC|(L_c', L_s)$.

$L_c$ and $L_c'$ are only different in the replacement of $c_1$ and $c_2$ by $c'$. Hence, there has to be a field declaration from $c_1$ or $c_2$ which reaches a class $rc \in \verb|RC|(L_c,L_s,\verb|distance|)$, and is not found in $c'$. However, the reachability through a field declaration is a relation included in $\verb|R|(c_1, L_s)$ or $\verb|R|(c_2, L_s)$, and we have that $\verb|R|(c_1, L_s) \subseteq \verb|R|(c', L_s) \land \verb|R|(c_2, L_s) \subseteq \verb|R|(c', L_s)$, which constitutes a contradiction.

Therefore, $\verb|TAC|$ fulfills property \textit{Merging of classes}.

\paragraph{Merging of unconnected classes}
Let $L_c$ and $L_s$ be a client and a server library respecively. Let $c_1$ and $c_2$ be classes implemented in $L_c$, such that $\verb|R|(c_1, L_s) \cap \verb|R|(c_2, L_s) = \emptyset$. Let $c'$ defined as $c' = c_1 + c_2$. Hence, $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$. Let $L_c'$ be a client library which is the result of replacing $c_1$ and $c_2$ by $c'$ in $L_c$.

Assume that the $\verb|TAC|$ does not fulfill \textit{Merging of unconnected classes}. This means that $\verb|TAC|(L_c, L_s) \neq \verb|TAC|(L_c', L_s)$. Since $\verb|TAC|$ has the property \textit{Merging of classes}, we know that $\verb|TAC|(L_c, L_s) \geq \verb|TAC|(L_c', L_s)$, which leaves $\verb|TAC|(L_c, L_s) > \verb|TAC|(L_c', L_s)$.

Then, there exists a field declaration in $c_1$ or $c_2$ which reaches a class included in $L_s$ and is not included in $c$. However, we have that $\verb|R|(c_1, L_s) + \verb|R|(c_2, L_s) = \verb|R|(c', L_s)$, which creates a contradiction.

Therefore, the metric $\verb|TAC|$ fulfills property \textit{Merging of unconnected classes}.

\section{Measuring coverage of the dependency}\label{sec:coverageMetrics}
The metrics presented in this section measure the dependencies from a different perspective. Instead of measuring import coupling between the client library and the server library, we look at how much of the server library is used by the client library. With these metrics, the developers, for example, can estimate the probability that a breaking change in a library affects their code.

\subsection{Definition of coverage}\label{subsect:usage-definition}
Just as with the coupling metrics, it is necessary to define the characteristics of the coverage that will be measured. In this case, there is no framework indicating which are the relevant characteristics to define, and with which criteria.

Therefore, based on the criteria discussed for the definition of coupling, we have created the list criteria applied in the coverage of a dependency.

\paragraph{Type of connection}
For these metrics, since it is not about coupling, but about how much of the server library is used by the client library, the metrics will not be focused solely on one type of connection. Instead, we will consider every type of connection in the measurement of coverage.

The types of connections discussed previously (see section \ref{subsect:defCoupling}) are some of the most common types of connection. Nevertheless, there are others which are also considered.

Given class \textit{a} and class \textit{b}...

\begin{itemize}
  \item ... class \textit{a} has an annotation of type \textit{b}.
  \item ... class \textit{a} has a declared field with an annotation of type \textit{b}.
  \item ... class \textit{a} has method \textit{m}, which has an annotation of type \textit{b}.
  \item ... class \textit{a} has method \textit{m}, which has a parameter with an annotation of type \textit{b}.
  \item ... class \textit{a} has method \textit{m}, which throws an exception of type \textit{b}.
\end{itemize}

\paragraph{Granularity}
In this case, we have to define a unit to measure which percentage of the server library units are being used by the client library. According to the type of connections, two different kinds of units can be used: methods and classes. For the goal of these metrics it is also necessary to use both units of measure. For example, the breaking changes of a library can be at a metric, or for an entire class, and we want to measure it for both cases. Therefore, we define two metrics, one for methods and another for classes. Nevertheless, the metrics' aggregation level is still at the library level since the goal is to measure the percentage of reachable units.

The last aspect of the granularity to consider is how the connections are evaluated. The goal is know how many items are reached, but not how many times. Therefore, we count the distinct items at the other end of the connections.

\paragraph{Direct \& Indirect}
Finally, we have to decide whether to consider indirect usage or not. Since we want to know the total percentage of coverage of the server library, we will consider both the units that are directly used and those indirectly used.

\paragraph{Result}
The metrics resulting from the description of coverage, can be found in Table \ref{table:usage-metric-characteristics}.

\begin{table}[ht!]
    \begin{center}
    \begin{tabular}{|l|l|l|l|l|l|}
    \hline
    \rot{Metric} & \rot{Type of connection} & \rot{Unit of measure} & \rot{Aggregation level} & \rot{Counting connections    } & \rot{Direct/Indirect} \\ \hline
    \% Reachable classes & All & Class   & Library & Distinct items & Both \\
    \% Reachable methods & All & Method  & Library & Distinct items & Both \\
    \hline
    \end{tabular}
    \end{center}
    \caption{Characteristics of the coverage metrics}
    \label{table:usage-metric-characteristics}
\end{table}

\subsection{Formal definition of the metrics}

\subsubsection{Percentage of reachable classes}
This metric calculates the percentage of coverage of a dependency using classes as the unit of measure. Therefore, it calculates the cardinality of the set of classes implemented in the server library ($L_s$) that are reachable from the code of the client library ($L_c$), denoted $\verb|RC|(L_c, L_s)$. The number of reachable classes is divided by the total number of classes in $L_s$.

As explained in section \ref{subsect:usage-definition}, all types of connections are considered for this metric. Hence, $\verb|RC|(L_c, L_s)$ includes all the classes reachable through any of the types of connection or a combination of these.

\begin{equation}
\label{eqn:reachable-classes}
    \verb|%ReachableClasses|(L_c, L_s) = \frac{|RC(L_c, L_s)|}{|C(L_s)|}
\end{equation}

\subsubsection{Pergentage of reachable methods}
This metric works exactly as the previous one, but instead of using the class as the unit of measure, it uses methods. Therefore, it divides the number of elements in the set of methods from the server library ($L_s$) that are reachable from the code of the client library ($L_c$), $RM(L_c, L_s)$, by the total number of methods ($|M(L_s)|$).

For this metric, since the unit of measure is the method, the only type of connection through which a method is reachable is the method call or method invocation. Thus, the methods included in the reachable classes are not considered reachable by default, since it is not sure if the method has been invoked.

\begin{equation}
\label{eqn:reachable-methods}
\verb|%ReachableMethods|(L_c, L_s) = \frac{|RM(L_c, L_s)|}{|M(L_s)|}
\end{equation}

\subsection{Theoretical validation}\label{subsect:theoretical-validation-usage}
In this section, the theoretical validation of the metrics \(\verb|%ReachableClasses|\) and \(\verb|%ReachableMethods|\) is done by proving the properties that these metrics should fulfill. Given that the two metrics are highly similar, the proofs are done for the first metric, namely \(\verb|%ReachableClasses|\), but could easily be done for the second one with the same reasoning.

The properties chosen for these metrics are the ones that the aspect being measured should have. We based the properties on the work by Srinivasan and Devi \cite{srinivasan2014software}, which reviews the methodologies to validate metrics in software engineering. We obtained the following list of properties, which apply to these metrics. The first two properties were originally described by Weyuker \cite{weyuker1988evaluating} and the last three by Briand et al. \cite{briand1996property}. Some properties are originally defined using the class as the aggregation level. Therefore, we adapted the definition of the properties to library as the aggregation level.

\begin{enumerate}
  \item \textbf{Noncoarseness:} Two different libraries can have different values for the same metric.
  \item \textbf{Nonuniqueness:} There can exist different libraries with the same value.
  \item \textbf{Nonnegativity:} The value of the metric should never be negative.
  \item \textbf{Null value:} The value of the metric is expected to be zero if there is no usage of the server library in the client library code.
  \item \textbf{Monotonicity:} It is expected that if more usage is added from the client library to the server library, the metric value does not decrease.
\end{enumerate}

\paragraph{Noncoarseness}
Let us consider the two cases in Figure \ref{fig:example-noncoarseness-reachable-classes}. In the first case, \texttt{Lib1} would be the client library, and \texttt{Lib2} the server library. In the example, we can see that the number of classes in the server library is: $|\verb|C|(Lib2)| = 3$. Also, the number of classes of the server library, reached by the client library is $|RM(Lib1, Lib2)| = 2$. Therefore, following the equation \ref{eqn:reachable-classes}, we have that \(\verb|%ReachableClasses|(Lib1, Lib2) = \frac{2}{3} = 0.66\).

In the second case in Figure \ref{fig:example-noncoarseness-reachable-classes} we take \texttt{Lib3} as the client library, and \texttt{Lib4} as the server library. Therefore, we have $|\verb|C|(Lib4)| = 3$ and $|RM(Lib3, Lib4)| = 3$, which means that the value of the metric is  \(\verb|%ReachableClasses|(Lib3, Lib4) = \frac{3}{3} = 1\).

Therefore, two different libraries can have different values for \(\verb|%ReachableClasses|\), which means that this metric fulfills the property \textit{Noncoarseness}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{figures/Example-Percentage-Classes-1.png}
\caption{Example of noncoarseness, percentage of reachable classes}
\label{fig:example-noncoarseness-reachable-classes}
\end{center}
\end{figure}

\paragraph{Nonuniqueness}
Following the first example in Figure \ref{fig:example-nonuniqueness-reachable-classes} we take \texttt{Lib1} as the client library, and \texttt{Lib2} the server library. Therefore, we can see that $|\verb|C|(Lib2)| = 3$, and $|RM(Lib1, Lib2)| = 2$. Hence, calculating the metric using equation \ref{eqn:reachable-classes}, we obtain \(\verb|%ReachableClasses|(Lib1, Lib2) = \frac{2}{3} = 0.66\).

In the second case in Figure \ref{fig:example-noncoarseness-reachable-classes} we have \texttt{Lib3} as the client library, and \texttt{Lib4} as the server library. Looking at the example, we know that $|\verb|C|(Lib4)| = 3$ and $|RM(Lib3, Lib4)| = 2$. Therefore, the metric for these two libraries is \(\verb|%ReachableClasses|(Lib3, Lib4) = \frac{2}{3} = 0.66\).

Therefore, two different libraries can have the same value for metric \(\verb|%ReachableClasses|\). Hence, the property \textit{Nonuniqueness} holds for this metric.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{figures/Example-Percentage-Classes-2.png}
\caption{Example of nonuniqueness, percentage of reachable classes}
\label{fig:example-nonuniqueness-reachable-classes}
\end{center}
\end{figure}

\paragraph{Nonnegativity}
Assume that the metric \(\verb|%ReachableClasses|\) does not fulfill this property.
Let $L_c$ be a client library, and $L_s$ be a server library, such that \(\verb|%ReachableClasses|(L_c, L_s) < 0\). Then, we have that $|RC(L_c, L_s)| < 0 \oplus |C(L_s)| < 0$. This means that the cardinality of a set is negative, which is not true by definition. Therefore, it is a contradition.

Hence, the metric fulfills property \textit{Nonnegativity}.

\paragraph{Null value}
Let $L_c$ be a client library, and $L_s$ be a server library. There is no usage in $L_c$ of library $L_s$, $RC(L_c, L_s) = \emptyset$. Assuming that the property null value does not hold for \(\verb|%ReachableClasses|\), then \(\verb|%ReachableClasses|(L_c, L_s) \neq 0\). Since this metric has the property nonnegativity, it follows that  \(\verb|%ReachableClasses|(L_c, L_s) > 0\).
Therefore, $\frac{|RC(L_c, L_s)|}{|C(L_s)|} > 0$ and $|RC(L_c, L_s)| > 0$, which contradicts that $RC(L_c, L_s) = \emptyset$.

Therefore, the property \textit{Null value} holds for metric \(\verb|%ReachableClasses|\).

\paragraph{Monotonicity}
Having $L_c$ a client library, and $L_s$ a server library. Let $c_c$ be a class in $L_c$, and $c_c'$ a class created as the result of adding more connections to $L_s$ in $c_c$. Then, let $L_c'$ be a client library resulting of replacing $c_c$ by $c_c'$ in $L_c$. Assuming that the property does not hold, we would have that \(\verb|%ReachableClasses|(L_c, L_s) > \verb|%ReachableClasses|(L_c', L_s)\).
Therefore, since $|C(L_s)|$ is the same in both cases because $L_s$ does not change, we have that $|RC(L_c, L_s)| > |RC(L_c', L_s)|$. This means that there is some $c_s$ in $L_s$, which is reachable from $c_c$ and not reachable from $c_c'$. However, $c_c'$ contains all the connections between $c_c$ and $L_s$, and that is therefore not possible.

In conclusion, the metric \(\verb|%ReachableClasses|\) has the property \textit{Monotonicity}.

\section{Measuring usage per class}

In this case, the goal is to give a lower-level information on the usage of the dependency from the client library. It can be useful for a developer or a maintainer to know exactly which parts of the code are using the dependency. For example, if there is a breaking change, or if the library with a dependency has to be replaced.

This section describes how the usage is measured by these metrics and provides a formal definition of the metrics. Finally, we perform a theoretical validation of the metrics.

\subsection{Definition of usage per class}
To define the usage to be measured by these metrics, we use the relevant criteria for this case.

\paragraph{Type of connection}
Just as with the coupling metrics, all the types of connection can be relevant, but the usage of each type of connection might have a different impact. Therefore, these should not be measured together. Since this work is meant to be the first approach, we select two possible connection types.

First, the \textit{method invocation}, since it is the only type of connection that refers to the methods used in the dependencies, and therefore is the only one indicating where the server libraries' methods can be invoked from. Then, to represent how the classes of the server libraries are used, and for consistency with the previous metrics, we select the \textit{field declaration}.

\paragraph{Granularity}

As the title of the section indicates, these metrics are measuring the usage \textit{per class}. Hence, the aggregation level of the metric is the \textit{class} level for the client library. In other words, we calculate the metric taking a class of the client library and a server library.

The way the connections are counted for these metrics is not considered in the original list created by Briand et al. \cite{briand1999unified}. Instead, it is counted the number of places of the client class where a connection is originated. For instance, let's take \texttt{Lib1} from Figure \ref{fig:example-impact-per-class} as the client library, and \texttt{Lib3} as the server library. From \texttt{Class1} to \texttt{Lib3} there are four different connections, but there are only two origins of these connections. The same happens with \texttt{Class2}, in which there are two connections with \texttt{Lib3}, but only one origin.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{figures/impact-per-class.png}
\caption{Example to calculate usage per class}
\label{fig:example-impact-per-class}
\end{center}
\end{figure}

\paragraph{Direct \& Indirect}

The connection measured can be either direct or indirect, depending on the dependency between the client and the server library. However, this does not change the calculation of the metric. Hence, both types of dependencies are calculated with the same metric.

\paragraph{Result}
Based on the criteria discussed above, we define two metrics. The summary of the characteristics of these two metrics can be found in Table \ref{table:per-class-characteristics}.

\begin{table}[h]
    \begin{center}
    \begin{tabular}{|l|l|l|l|l|}
    \hline
    Metric & Type of connection & Aggregation level & Counting connections & Direct/Indirect \\ \hline
    \#1 & Method invocation & Class & \#origin of connection & Both \\
    \#2 & Field declaration & Class & \#origin of connection & Both \\
    \hline
    \end{tabular}
    \end{center}
    \caption{Criteria of the set of metrics}
    \label{table:per-class-characteristics}
\end{table}

\subsection{Formal definition of the metrics}
In this section, we provide a formal definition of the metrics \textit{method invocations per class} and \textit{field declarations per class}.

\paragraph{Method invocations per class}
Having a client library ($L_c$), and a server library ($L_s$). The result of this metric for a class of the client library ($c_c \in \verb|C|(L_c)$) corresponds to the number of method invocations contained in the methods of $c_c$ ($m_c \in \verb|M|(c_c)$) such that, the call graph created from these method invocations reach a method implemented in the client library ($m_s \in \verb|M|(L_s)$). The set with the method invocations in $m_c$ that reach a method in $L_s$ is $\verb|nIR|(m_c, L_s)$.

\begin{equation}
\label{eqn:mi}
    \verb|#MethodInvocations|(c_c, L_s) =  \sum_{m_c \in \verb|M|(c_c)} |\verb|nIR|(m_c, L_s)|
\end{equation}

\paragraph{Field declaration per class}
This metric is calculated in the following manner. For a class $c_c$ of a client library $L_c$ ($c_c \in \verb|C|(L_c)$), and a server library $L_s$. The result of the metric for $c_c$, corresponds to the number of field declarations in $c_c$ such that, through field declarations reach a class implemented in $L_s$. The set of field declarations that reach $L_s$ is denoted $\verb|nFR|(c_c, L_s)$.

\begin{equation}
\label{eqn:fd}
    \verb|#FieldDeclarations|(c_c, L_s) = |\verb|nFR|(c_c, L_s)|
\end{equation}

\subsection{Theoretical validation}
This section contains the proofs, for the metrics $\verb|#MethodInvocations|$ and $\verb|#FieldDeclarations|$, of the properties that these should have. The proofs are done for one metric since they can be done for the other metric very similarly.

The properties chosen in this case are the same as the ones chosen in Section \ref{subsect:theoretical-validation-usage} since these properties can also be applied for these metrics. Nevertheless, the description of the properties has been adapted to fit the characteristics of the metrics.

\begin{enumerate}
  \item \textbf{Noncoarseness:} Two different classes can have different values for the same metric.
  \item \textbf{Nonuniqueness:} There can exist different classes with the same value.
  \item \textbf{Nonnegativity:} The value of the metric should never be negative.
  \item \textbf{Null value:} The value of the metric is expected to be zero if there is no connection of the type measured by the metric from the client class to the server library.
  \item \textbf{Monotonicity:} It is expected that if more usage is added from the client class to the server library, the metric value does not decrease.
\end{enumerate}

\paragraph{Noncoarseness}
Following the first case in Figure \ref{fig:example-noncoarseness-method-invocation}, we take textit{Lib1} as the client library, \texttt{Lib2} as the server library, and the only class in \texttt{Lib1} as $c_c$. We can see that the class has only one method, for which $|\verb|nIR|(Method, Lib2)| = 1$. Following the equation \ref{eqn:mi}, $\verb|#MethodInvocations|(c_c, Lib2) = 1$.

Now we move to the second case in Figure \ref{fig:example-noncoarseness-method-invocation}. In this case we take \texttt{Lib3} as the client library, \texttt{Lib4} as the server library, and the class in \texttt{Lib3} as $c_c$. Class $c_c$ has only one method, for which $|\verb|nIR|(Method, Lib4)| = 3$. Hence, $\verb|#MethodInvocations|(c_c, Lib4) = 3$.

In conclusion, two different classes can have different values for metric $\verb|#MethodInvocations|$, which fulfills property \textit{Noncoarseness}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{figures/Example-Distribution-1.png}
\caption{Example of noncoarseness, number of method invocations}
\label{fig:example-noncoarseness-method-invocation}
\end{center}
\end{figure}

\paragraph{Nonuniqueness}
Now we look at Figure \ref{fig:example-nonuniqueness-method-invocation}, and in the first example we take \texttt{Lib1} as the client library, \texttt{Lib2} the server library, and the class in \texttt{Lib1} as the client class, $c_c$. The client class has only one method, for which $|\verb|nIR|(Method, Lib2)| = 2$. Therefore, $\verb|#MethodInvocations|(c_c, Lib2) = 2$.

Focusing on the second case in Figure \ref{fig:example-nonuniqueness-method-invocation}, we have that \texttt{Lib3} is the client library and \texttt{Lib4} the server library. Also, the client class, $c_c$, is the only class in \texttt{Lib3}. We can see that there is one method in $c_c$, which calls \texttt{Lib4} a total of 2 times, $|\verb|nIR|(Method, Lib4)| = 2$. Hence, $\verb|#MethodInvocations|(c_c, Lib4) = 2$.

With this example, we see that two different classes can have the same value for $\verb|#MethodInvocations|$. Therefore, this metric fulfills the property \textit{Nonuniqueness}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{figures/Example-Distribution-2.png}
\caption{Example of nonuniqueness, number of method invocations}
\label{fig:example-nonuniqueness-method-invocation}
\end{center}
\end{figure}

\paragraph{Nonnegativity}
If the property does not hold for $\verb|#MethodInvocations|$, there exists a client library $L_c$ containing $c_c$ and a server library $L_s$, such that $\verb|#MethodInvocations|(c_c, L_s)
< 0$. Therefore, a method $m_c \in \verb|M|(c_c)$, exists such that $|\verb|nIR|(m_c, L_s)| < 0$. However, the cardinality of a set cannot be negative by definition, and therefore it is a contradition.

Hence, the property \textit{Nonnegativity} holds for metric $\verb|#MethodInvocations|$.

\paragraph{Null value}
Assume that the metric does not fulfill property null value. Let $L_c$ and $L_s$ be a client library and a server library, adn $c_c$ a class in $L_c$. Assume that $c_c$ does not have any connection to $L_s$, and given that the metric does not fulfill \textit{null value}, $\verb|#MethodInvocations|(c_c, L_s) \neq 0$. From the previous proof we know that $\verb|#MethodInvocations|(c_c, L_s) \geq 0$, then  $\verb|#MethodInvocations|(c_c, L_s) > 0$.
Hence, there is a method $m_c \in \verb|M|(c_c)$ such that $|\verb|nIR|(m_c, L_s)| > 0$. Since $\verb|nIR|(m_c, L_s)$ is the set of method invocations in $c_c$ that reach $L_s$, there has to be a connection between $c_c$ and $L_s$, which constitutes a contradition.

Therefore, the metric fulfills property \textit{Null value}.

\paragraph{Monotonicity}
Let $L_c$ be a client library, and let $L_s$ be a server library. Given a class $c_c$ in $L_c$, we define $c_c'$ as a copy $c_c$ with added connections to $L_s$. Let $L_c'$ be a client library identical to $L_c$,. but in which $c_c$ has been replaced by $c_c'$. Assume that metric $\verb|#MethodInvocations|$ does not fulfill \textit{Monotonicity}. Therefore, $\verb|#MethodInvocations|(c_c, L_s) > \verb|#MethodInvocations|(c_c, L_s)$.
Then, for a given $m_c \in \verb|M|(c_c)$, and its copy in $c_c'$, $m_c' \in \verb|M|(c_c')$, such that $|\verb|nIR|(m_c, L_s)| > |\verb|nIR|(m_c', L_s)|$. This means that $m_c$ contains a method invocation which reaches $L_s$ and it is not included in $m_c'$. However, all the method invocations contained in $c_c$ are maintained in $c_c'$. Therefore, it is a contradition.

Hence, property \textit{Monotonicity} holds for metric $\verb|#MethodInvocations|$.
