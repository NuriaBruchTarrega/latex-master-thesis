% !TEX root = ../main.tex
\chapter{Proof of Concept}\label{ch:PoC}

% Right now I'm only measuring dependencies in the scope compile and provided. It might be nice to also add dependencies in scope test, but the connections to those dependencies are problably not method calls, but rather other types of connections such as annotations.

\section{Measuring coupling metrics (RQ1.3)}
There are several techniques that could have been used to implement the PoC that calculates the different metrics proposed.

\begin{itemize}
  \item Bytecode analysis
  \item Source code analysis
  \item Call-level dependency graph
\end{itemize}

After an initial try, source code analysis has been discarded. The reason for it is that the source code is needed for both the client library, and all its dependencies. Although Maven can provide the source code for some of the artifacts, it is not available as often as the bytecode.

The option of call-level dependency graphs is useful for the metrics that measure the type of connection 6 (method invocation). However, the information needed for the type of connection: 1 (aggregation coupling), is not contained in the call-level graphs. Therefore, the approach to develop this PoC has been bytecode analysis. Furthermore, obtaining the call-graphs of the complete dependency tree has not been possible, since creating this types of fine-grained call-graphs is still a work in progress.

\subsection{Bytecode analysis}
The PoC implementation to calculate the proposed coupling metrics uses bytecode analysis. The implementation is supported by the libraries \textit{Javassist}\footnote{\url{http://www.javassist.org/}}, and \textit{Aether}\footnote{\url{https://wiki.eclipse.org/Aether/What_Is_Aether}}.

\paragraph{Aether}
Aether is a library created by Eclipse, which allows to fetch Maven artifacts from different repositories. In addition, it is also used to resolve the dependencies of a library, and create the dependency tree. To create the dependency tree, Aether uses the same strategy to resolve the dependencies as Maven.

In the PoC, it has been used for the initial steps. The request to calculate the metrics receives the identifiers of the library to analyze (\textit{GroupID}, \textit{ArtifactID}, and \textit{version}). Aether fetches the library \textit{jar} and \textit{POM} files from the Maven Central Repository.

Then, once the artifact of the client library is obtained, \textit{Aether} is used to resolve the dependencies of the artifact. For the calculation of the metrics to be possible, all the dependencies of the client library should also be available in Maven. The dependency tree of the artifact is visited, and each of the dependencies are also obtained, in order to have the \textit{jar} files to analyze as well. In addition, the dependency tree calculated with Aether is also used to create a custom dependency tree with the class \texttt{DependencyTreeNode} which is used to store the needed data about each of the libraries during the process of calculating the metrics.

\paragraph{Javassist}
Once the jars of the client library and all its dependencies are available, the first step is to join all the \textit{.class} files in a \texttt{ClassPool} object, which is the main object of \textit{Javassist}. Once the \texttt{ClassPool} is created, it is used to obtain the classes from the client library, from which the different metrics are calculated.

\subsubsection{Implementation Classes}
\paragraph{Model of the dependency tree}
In order to represent the dependency tree of the client library, the implementation uses the class \texttt{DependencyTreeNode}. Each \texttt{DependencyTreeNode} contains the information of the library it represents, namely \textit{groupID}, \textit{artifactID}, and \textit{version}. Also, each \texttt{DependencyTreeNode} has a \texttt{List} of \texttt{DependencyTreeNode}, which are the children of the current library in the dependency tree.

To store all the information about the metrics, each \texttt{DependencyTreeNode} has, in addition, two fields: \texttt{ReachableBehaviors}, \texttt{ReachableClasses}, for metrics \texttt{MIC} and \texttt{AC}, respectively. \texttt{ReachableBehaviors} is a map, containing for each reachable method or constructor (behavior) of the server library, a \texttt{Set} with all the method calls from which it is reachable. In the same way, \texttt{ReachableClasses} is a map, in which for each reachable class of a server library, there is a \texttt{Set} of all the field declarations from which the class is reachable.

\unsure{add class diagram of the model?}

\subsubsection{Direct Method Invocation Coupling}
The pseudo-code in Figure \ref{fig:algorithm-mic} represents the algorithm used to calculate the metric MIC for each one of the direct dependencies of a given client library. The output of the algorithm is a map containing the set of \texttt{BehaviorCalls} that call each \texttt{CtBehavior}. The map is generated for each one of the direct dependencies and stored in the \texttt{DependencyTreeNode} of each library.

The class \texttt{CtBehavior} represents a method, it contains the information about the method itself, and about the class that contains the method. Each of the \texttt{CtMethod} are used later on to find the polymorphic implementations of the method, as well as to calculate the transitive dependencies.

To calculate this first metric, the PoC tool iterates through all the classes of the client library (line 3). For each class, the behaviors are obtained (line 4). In the \textit{Javassist} terminology, the behaviors include both methods and constructors.

Then, the tool iterates through all the behaviors (line 5), and calls the method \texttt{instrument}. The main use case of this method is to modify the bytecode of the method. The method \texttt{instrument} receives an \texttt{ExprEditor} object, which is a class that can be extended to implement the methods for editing the bytecode, which are empty by default. To calculate this metric, the overridden methods are \texttt{edit(MethodCall mc)}, \texttt{edit(ConstructorCall cc)}, and \texttt{edit(NewExpr ne)}. These methods will be called for each method call or constructor call, existing in the bytecode of the method (line 6). The constructor calls in the form of \texttt{this()} or \texttt{super()} are captured by the method \texttt{edit(ConstructorCall cc)}. Whereas the constructor calls in the form of \texttt{new Object()} are captured by \texttt{edit(NewExpr ne)}.

For each captured call to a behavior, it is checked if the called behavior belongs to a server library (line 9). In case it does, the call is added to the \texttt{ReachableBehaviors} map of the server library (line 10).

\begin{figure}[ht!]
\begin{lstlisting}[escapeinside={(*}{*)}]
clientClasses = classPoolManager.getClientLibraryClasses()

for each c in clientClasses
  behaviors = c.getDeclaredBehaviors()
  for each behavior in behaviors
    for each behaviorCall in behavior
      serverBehavior = behaviorCall.getBehavior()
      serverClass = serverBehavior.getDeclaringClass()
      if (classPoolManager.belongsToClientLibrary(serverClass))
        dependencyTreeNode.addReachableBehavior(serverBehavior, behaviorCall)
\end{lstlisting}
\caption{Pseudo-code of the algorithm to calculate MIC}
\label{fig:algorithm-mic}
\end{figure}

\subsubsection{Direct Aggregation Coupling}
The pseudo-code in Figure \ref{fig:algorithm-ac} represents the algorithm used to calculate the metric AC. The output of the algorithm is a map containing for each \texttt{CtClass} of the server library, the set of \texttt{CtField} that are of the type of the \texttt{CtClass}. The class \texttt{CtClass} represents a class and contains the information of the class and the library where it is implemented. \texttt{CtClass} is used later on to find the descendants of the class, and to calculate the metric \texttt{TAC} for the transitive dependencies.

The algorithm for this second metric is similar to the previous one. The implementation iterates through all the classes of the client library (line 3). Then, for each class, it iterates through all the declared fields (line 5). Next, each of the fields containing a generic type are parsed separatedly (line 6), to obtain all the types icluded in the generic  (line 7), which are treated individually (line 8). All the simple fields, if the implementation of the class is found in a server library (line 13), are included in the calculation of the metric (line 14).

\begin{figure}[ht!]
\begin{lstlisting}[escapeinside={(*}{*)}]
clientClasses = classPoolManager.getClientLibraryClasses()

for each c in clientClasses
  fields = c.getDeclaredFields()
  for each field in fields
    if (field.containsGeneric())
      serverClasses = getAllClasses(field)
      for each serverClass in serverClasses
        if (classPoolManager.belongsToClientLibrary(serverClass))
          dependencyTreeNode.addClass(serverClass, field)
    else
      serverClass = field.getType()
      if (classPoolManager.belongsToClientLibrary(serverClass))
      dependencyTreeNode.addReachableClass(serverClass, field)
\end{lstlisting}
\caption{Pseudo-code of the algorithm to calculate AC}
\label{fig:algorithm-ac}
\end{figure}

\paragraph{Inheritance}
Once the two algorithms (Figures \ref{fig:algorithm-mic} and \ref{fig:algorithm-ac}) are finished, in order to follow the definition of the metrics as specified in section \ref{subsec:metric-definition} the hierarchies in the server libraries are visited. For the metric \texttt{MIC} all the polymorphic implementations of the behaviors are found, and for the metric \texttt{AC} all the descendants of the classes.

The algorithms to find the descendants and the polymorphic implementations of the methods, are used with each one of the libraries with which the client library has a direct dependency, and for which coupling was found, either \texttt{MIC} or \texttt{AC}.

The pseudo-code used to find the polymorphic implementations of the methods can be found in Figure \ref{fig:algorithm-polymorphy}. The process is as follows: First, iterate through all the classes of the server library, given its \texttt{DependencyTreeNode} (line 5). Then, it iterates through the behaviors in the map contained in \texttt{ReachableBehaviors}. If the current library class is a descendant of the class containing the reachable behavior (line 8), and it contains a behavior with the same signature as the reachable behavior (line 9), a polymorphic implementation of the behavior has been found. Therefore, the found behavior is added to the \texttt{ReachableBehaviors} with the same set of \texttt{BehaviorCall} as the reachable behavior (line 11).

\begin{figure}[ht!]
\begin{lstlisting}[escapeinside={(*}{*)}]
serverLibrary = dependencyTreeNode.getLibrary()
reachableBehaviorsMap = dependencyTreeNode.getReachableBehaviors()
serverLibraryClasses = classPoolManager.getLibraryClasses(serverLibrary)

for each serverClass in serverLibraryClasses
  for each reachableBehavior in reachableBehaviorsMap
    declaringClass = reachableBehavior.getDeclaringClass()
    if (serverClass.isSubClassOf(declaringClass))
      if (serverClass.containsBehavior(reachableBehavior.getSignature()))
        serverBehavior = serverClass.getBehavior(reachableBehavior.getSignature())
        dependencyTreeNode.addReachableBehavior(serverBehavior, reachableBehavior.getBehaviorCalls())
\end{lstlisting}
\caption{Pseudo-code of the algorithm to find polymorphic implementations}
\label{fig:algorithm-polymorphy}
\end{figure}

The process to find descendants in the case of the metric \texttt{AC} is the same as the one in Figure \ref{fig:algorithm-polymorphy}, but iterating over the \texttt{reachableClassesMap} instead of the \texttt{reachableBehaviorsMap}. Therefore, if the server class is sub-class of a reachable class, it is added to the \texttt{ReachableClasses} of the library.

\blankl
As can be observed in the previous explanation of how the detection of inheritance is done, in this PoC implementation, it is not detected if a class is extended in the client library instead of in the server library.\todo{Find out how often does this happen}

\subsubsection{Transitive Method Invocation Coupling}

\begin{figure}[ht!]
\begin{lstlisting}[escapeinside={(*}{*)}]
toVisit = queue(clientLibraryNode.getChildren())

while (!toVisit.isEmpty())
  visiting = toVisit.poll()
  if (visiting.hasReachableBehaviors())
    findPolymorphicImplementations(visiting.getReachableBehaviors())
  if (visiting.hasChildren())
    calculateTransitiveMIC(visiting)
  toVisit.add(visiting.getChildren())
\end{lstlisting}
\caption{Pseudo-code of the algorithm to find polymorphic implementations}
\label{fig:tree-iterating-tmic}
\end{figure}

\begin{figure}[ht!]
\begin{lstlisting}[escapeinside={(*}{*)}]
reachableBehaviors = visitingTreeNode.getReachableBehaviors()

for each reachableBehavior in reachableBehaviors
  behaviorsToVisit = queue(reachableBehavior)
  visitedBehaviors = empty set
  while (!behaviorsToVisit.isEmpty())
    visitingBehavior = behaviorsToVisit.poll()
    if (visitedBehaviors.contains(visitingBehavior)) continue
    visitedBehaviors.add(visitingBehavior)

    for each behaviorCall in visitingBehavior
      calledBehavior = behaviorCall.getBehavior()
      calledClass = calledBehavior.getDeclaringClass()
      if (classPoolManager.isStandardClass(calledClass))
        continue
      else if (classPoolManager.isClassInDependency(calledClass, visitingLibrary))
        visitingLibrary.addReachableBehaviorToDependency(calledClass)
      else // calledClass is in current library
        behaviorsToVisit.add(calledBehavior)
\end{lstlisting}
\caption{Pseudo-code of the algorithm to find polymorphic implementations}
\label{fig:calculate-tmic}
\end{figure}

\subsubsection{Transitive Aggregation Coupling}

\begin{figure}[ht!]
\begin{lstlisting}[escapeinside={(*}{*)}]
toVisit = clientLibraryNode.getChildren()

while (!toVisit.isEmpty())
  visiting = toVisit.poll()
  if (visiting.hasReachableClasses())
    findPolymorphicImplementations(visiting.getReachableClasses())
  if (visiting.hasChildren())
    calculateTransitiveAC(visiting)
  toVisit.add(visiting.getChildren())
\end{lstlisting}
\caption{Pseudo-code of the algorithm to find polymorphic implementations}
\label{fig:tree-iterating-tac}
\end{figure}

\begin{figure}[ht!]
\begin{lstlisting}[escapeinside={(*}{*)}]
reachableClasses = visitingTreeNode.getReachableClasses()

for each reachableClass in reachableClasses
  classesToVisit = queue(reachableClass)
  visitedClasses = empty set
  while (!classesToVisit.isEmpty())
    visitingClass = classesToVisit.poll()
    if (visitedClasses.contains(visitingClass)) continue
    visitedClasses.add(visitingClass)

    fields = visitingClass.getDeclaredFields()
    for each field in fields
      if (field.containsGeneric())
        classesInField = getAllClasses(field)
        for each classInField in classesInFIeld
          if (classPoolManager.isStandardClass(classInField)) continue
          else if (classPoolManager.isClassInDependency(classInField, visitingLibrary))
            visitingLibrary.addReachableClassToDependency(classInField)
          else // classInField is in current library
            classesToVisit.add(classInField)
      else
        classInField = field.getType()
        if (classPoolManager.isStandardClass(classInField)) continue
        else if (classPoolManager.isClassInDependency(classInField, visitingLibrary))
          visitingLibrary.addReachableClassToDependency(classInField)
        else // classInField is in current library
          classesToVisit.add(classInField)
\end{lstlisting}
\caption{Pseudo-code of the algorithm to find polymorphic implementations}
\label{fig:calculate-tac}
\end{figure}

\section{Visualization}
Until now, in this chapter, it has been described how the implementation works for the backend part. In this section, however, we are going to explain how the visualization of the tool has been designed and implemented.

This section contains a brief description of the technologies and libraries used to develop the visualization of the application, and a description of each part of the visualization.

For each part of the visualization, we are going to discuss different visual aspects of the visualization following the structure used by Kula et al. \cite{kula2014visualizing}. However, since the tool implemented for this thesis is meant to be interactive, we have added a new aspects, interactivity. These visual aspects are: Layout, shape, color, and interaction.

\subsection{Technologies}
The visualization has been implemented using the framework \texttt{Angular}\footnote{\url{https://angular.io/}}. Most of the UI elements used are obtained from \texttt{Angular Material}\footnote{\url{https://material.angular.io/}}. Finally, for graph representations we have used \texttt{vis.js}\footnote{\url{https://visjs.org/}}, and \texttt{ngx-charts}\footnote{\url{https://github.com/swimlane/ngx-charts}} for charts.

\subsection{Dependency Tree}\label{sec:visualization-dependency-tree}
The goal for the first visualization element is to provide an overview of the dependency tree of the client library, after being resolved with the Maven algorithm. In this overview, the maintainer should be able to see the degree of dependency with each of the dependencies of the client library. Furthermore, the unused dependencies should be easily identifiable. % And maybe also the most used ones.
\todo{add example image}

\paragraph{Layout}
Since this visualization displays the dependency tree of the client library, the chosen layout is a \textit{graph}. In particular, it is a \textit{tree}. In this graph, each node represents a library, and each edge a dependency between the nodes. The tree is organized by levels, such that the first level only contains the client library, and the second level the direct dependencies. The rest of the levels are organized according to the dependencies of the previous levels.

Each node displays the following information about the library: \texttt{GroupID}, \texttt{ArtifactID}, \texttt{version}, and the result of the metrics - \texttt{MIC} and \texttt{AC} for the direct dependencies, and \texttt{TMIC} and \texttt{TAC} for the transitive dependencies.

\paragraph{Shape}
For this visualization, the shape of each of the nodes is the same, an elipse. This is because the differentiation between the nodes is done with the color of the node, and not the shape. Furthermore, the elipse is the shape that allows to display all the necessary information in the node, without taking too much extra space.

\paragraph{Color}
The color palette used in all the different elements of the visualization has \textit{deep-purple} as primary color, and \textit{pink} as accent color. Hence, most of the nodes have different shades of \textit{deep-purple}. The node representing the client color is \textit{pink}, and the nodes representing libraries for which the value of all the metrics is 0 are \textit{light-grey}. For the rest of the nodes, the direct dependencies have a darker shade of \textit{deep-purple}, and the transitive dependencies a lighter one. \reminder{Maybe, I'll change this and the color of the rest of the nodes will range according to the degree of dependency}
In addition, when a node is selected (see next paragraph), the color of the node changes to a \textit{light-pink}.

\paragraph{Interaction}
The main problem with the dependcy tree visualization is that if the tree contains too many node, it is very difficult to see the content of the nodes. To fix this, all the nodes can be selected. When a node is selected, the visualization zooms in the selected node, so the user can see the content.

There are two ways to select a node. The first one is by clicking the node. The second option is by finding the node in the search bar. The search bar has been implemented to give suggestions containing the names of all the libraries displayed in the tree. To clear the node selection, the user has to click in the graph view, outside of any node.

The second type of interaction has been implemented to display some additional information of the nodes. When a user hovers over a node, a \textit{tooltip} appears. The \textit{tooltip} contains two tables displaying, for each metric, the value measured and the distance at which the value was measured.

\subsection{Distribution per class}
With the first visualization, the user has an overview of the dependency tree. However, there is no way the user can have more detailed information about a specific library of the dependency tree. Therefore, and making use of the node selection implemented in the visualization described in section \ref{sec:visualization-dependency-tree}, we have created a visualization to display how the distribution of the dependency among the classes of the client library.\todo{Add example visualization}

\paragraph{Layout}
The chosen layout for this visualization is a multi-chart. The chart contains two values for each represented class: the calculated \texttt{MIC} and the calculated \texttt{AC}.\reminder{And TMIC, TAC? Maybe I should also use the propagation formula here} Only the classes for which at least one of the two metrics is measured appear in the chart. \reminder{I could also sort the classes by some of the metrics, or make the chart scrollable to avoid very thin bars}

\paragraph{Shape}
The shape chosed for this chart is the bar. The line was discarded since, it is not the goal to show any kind of progression between the different classes. Hence, the chart used is a multi-barchart.
At the x-axis of the chart, only the simple names of the classes are displayed, in order to avoid having too much text in the chart. In the y-axis, there is a numeric scale, which corresponds to the measured \texttt{MIC} and \texttt{AC}.

\paragraph{Color}
To follow the palette used for the rest of the frontend of this tool, the bars displaying the \texttt{MIC} value have \textit{deep-purple} color, while the bars displaying the \texttt{AC} value are \textit{pink}.

\paragraph{Interaction}
This visualization appears and disappears according to the node selection of the dependency tree visualization.

In addition, if the user hovers over a column, a tooltip appears. This tooltip contains the values of the measured metrics (since these values are not displayed in the chart). In addition, it also contains the fully-qualified name of the class, to indicate the user where to find the class.
