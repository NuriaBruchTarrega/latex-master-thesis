% !TEX root = ..\main.tex
\chapter{Background}\label{ch:Background}
In this chapter we present the background information needed for this thesis. In addition, we also define some terminology that is going to be used in throughout the thesis.

\section{Terminology}
In this section, we are going to review the terms used in the related literature, comparing which terms are used in which papers. Then, we will explain the differences in both, the words and the meaning. Finally, we will specify the terms used in this thesis and their definition.

\begin{table}[htb!]
    \begin{center}
    \begin{tabular}{|l|c|c|c|c|}
    \hline
    Term & \cite{pashchenko2018vulnerable} & \cite{kikas2017structure} & \cite{fasten2019survey} & \cite{soto2020comprehensive} \\
    \hline
    Library                           & x &   & x & x \\
    Package                           &   & x & x &   \\
    Application                       &   & x &   &   \\
    Project                           & x & x &   & x \\
    \hline
    Version                           &   & x & x & x \\
    Instance                          & x &   &   &   \\
    Release                           &   &   & x &   \\
    Artifact                          &   &   &   & x \\
    \hline
    Package manager                   &   &   & x & x \\
    Package repository                &   &   & x &   \\
    \hline
    Dependency                        & x & x & x & x \\
    Reverse dependency                &   & x &   &   \\
    Inherited dependency              &   &   &   & x \\
    Direct/Transitive dependency      & x & x & x & x \\
    Direct/Indirect dependency        &   &   & x &   \\
    Deployed/non-deployed dependency  & x &   & x &   \\
    Own/third-party dependency        & x &   &   &   \\
    Halted dependency                 & x &   & x &   \\
    Bloated dependency                &   &   &   & x \\
    \hline
    Dependency tree                   & x &   &   & x \\
    Dependency network                &   & x & x &   \\
    Ecosystem                         &   & x &   &   \\
    \hline
    \end{tabular}
    \end{center}
    \caption{Terminology from the literature}
    \label{table:terminology}
\end{table}

\blankls
First, we are going to discuss the differences between the first four terms of the table. A library is a unit of software, which is distributed separatedly, and can be reused in other software components. The term library is in some cases substituted by the term package. The term application is used to differentiate the software components that are available in repositories to be reused (libraries) and those that are not (applications) \cite{kikas2017structure}.
The term project, is used in different papers with different meanings. Pashchenko et al. \cite{pashchenko2018vulnerable} use it to refer to a group of libraries that are developed or maintained by the same team of developers. Kikas et al. \cite{kikas2017structure} use it to refer to both library and application. Finally, Soto-Valero et al. use it to refer to Maven Projects.

Each library, available in a package repository, can have different versions. A part from the word version, the literature also uses the terms instance and release, but with the same meaning. Artifact, is used by Soto-Valero et al. to refer to a Maven Artifact, which corresponds to a version of a Maven Project.

The papers that specifically define package manager or package repository in the terminology, it is because these tools have an important role in the research.

When describing the relationship in which a library uses another, all the papers use the term dependency. Then, depending on the focus of the research of each paper, different types of dependencies are defined.

\unsure{Should I explain all the different types of dependencies here, or only those that I will use during the thesis?}

Finally, the terms dependency tree and dependency network are used to refer to the graph created by the dependencies, in which the library versions are the nodes and the dependencies are the edges. The ecosystem includes all the libraries and applications involved in the dependency network.

\blankl
Based on the terminology discussed above, we define the terms that are used within this thesis.

\begin{itemize}
  \item \textbf{Library:} A software artefact distributed individually. It can have different implementations distinguished by versions.

  \item \textbf{Version:} A version of a library. Contains an implementation of the library. Each version has a specific metadata associated to build the version sucessfully. Among other data, it specifies which versions of other libraries is it using.

  \item \textbf{Dependency:} When a library version uses a version of another library, it creates a relationship between the versions of the two libraries, a dependency. In particular, the first library version depends on the second one.

  \item \textbf{Direct and transitive dependencies:} A direct dependency is when a library version directly uses a version of another library. A transitive dependency is given when a library version uses another one indirectly, through other library versions that it depends on.

  \item \textbf{Halted dependencies:} A dependency with a library has not been updated (a new version released) for a much longer time than the usual release interval is considered a halted dependency.

  \item \textbf{Bloated dependencies:} A dependency is bloated when it is included in the dependency set of a library version, but it is not really used at any time. This could happen with both, direct and transitive dependencies, for different reasons.

  \item \textbf{Dependency network:} Graph that represents the dependencies between library versions. In a dependency network, the library versions are the nodes, and the dependencies between them are the edges.

  \item \textbf{Ecosystem:} A set of libraries that have versions with dependencies. When the libraries are updated (new versions), the ecosystem evolves.
\end{itemize}

\section{Dependency management}

\section{Dependency Networks}
\subsection{Package Dependency Network (PDN)}
\subsection{Call Dependency Network (CDN)}

\section{Coupling}
When assessing the quality of software, there are many aspects that are considered and measured. One of these, in particular for Object-Oriented systems, is coupling. Coupling measures the degree of dependency between two different parts of a system. In the literature of coupling metrics, these have been used to measure the dependency of the elements of the same system, or to give an overview of the coupling within a system. However, in this thesis we measure the coupling, or degree of dependency, between two different systems.

As described in section \ref{section:scope}, this thesis is focused in the structural metrics, based on static source code analysis.

There are many structural coupling metrics, each one measuring a different type of coupling from a different perspective, depending on the purpose for which the metrics are needed. In order to define type of metric needed to measure the dependency between products, we have used the framework defined by Briand et al. \cite{briand1999unified}, which unifies the frameworks defined by Eder et al. \cite{eder1994coupling}, Hitz and Montazeri \cite{hitz1995measuring}, and Briand et al. \cite{briand1997investigation}.

According to the unified framework defined by Briand et al., the coupling metrics have certain characteristics defining which type of coupling are they measuring. In particular, six criteria are defined:

\begin{itemize}
  \item \textbf{Type of connection:} This criteria defines which mechanism creates coupling, which type of dependency is measured, how the two elements are connected. The different types of connection, as described by Briand et al. \cite{briand1999unified} can be found in Table \ref{table:types-connections}.

  \item \textbf{Locus of impact:} If the coupling is import or export. In other words, if the class for which coupling is being measured is the client or the server of the relationship.

  \item \textbf{Granularity of the measure:} The detail at which the metric calculates coupling. It is defined by 1) The domain at which coupling is measured (e.g. class-level) and 2) how the metric counts the connections (e.g. binary evaluation or counting each one of the connections). The six options to count connections as defined by Briand et al. \cite{briand199unified}, can be found in Table \ref{table:counting-connections}.

  \item \textbf{Stability of the server:} In the framework by Briand et al. the servers are classified as unstable if these are  "subject to development or modification in the project at hand", and stable if these "are not subject to change in the project at hand". The last one includes classes imported from libraries. According to Briand et al., the coupling with an unstable class is represents more risk than coupling with a stable class. However, the studied metrics in the framework do not make use of this criteria, and treat all classes with the same importance.

  \item \textbf{Direct and indirect coupling:} Whether the connection between the two elements is direct, or transitive (there is at least one other element connecting the two). The metrics that do not account for indirect coupling, can be adapted by calculating the transitive closure of the metric.

  \item \textbf{Inheritance:} In this criteria, Briand et al. group the position of the metric respecting special cases such as inheritance and polymorphism.
\end{itemize}

\begin{table}[ht!]
    \begin{center}
    \begin{tabularx}{\textwidth}{|l|l|l|X|}
    \hline
    \# & Client Item & Server Item & Description \\
    \hline\hline
    1   & attribute \textit{a} of a class \textit{c} & class \textit{d}, d != c & class \textit{d} is the type of \textit{a} \\
    \hline
    2   & method \textit{m} of a class \textit{c} & class \textit{d}, d != c  & class \textit{d} is the type of a parameter of \textit{m}, or the return type of \textit{m} \\
    \hline
    3   & method \textit{m} of a class \textit{c} & class \textit{d}, d != c  & class \textit{d} is the type of a local variable of \textit{m} \\
    \hline
    4   & method \textit{m} of a class \textit{c} & class \textit{d}, d != c  & class \textit{d} is the type of a parameter of a method invoked by \textit{m} \\
    \hline
    5   & method \textit{m} of a class \textit{c} & \begin{tabular}[c]{@{}l@{}}attribute \textit{a} of a\\ class \textit{d}, d != c \end{tabular}  & \textit{m} references \textit{a} \\
    \hline
    6   & method \textit{m} of a class \textit{c} & \begin{tabular}[c]{@{}l@{}}method \textit{m'} of a\\ class \textit{d}, d != c \end{tabular} & \textit{m} invokes \textit{m'} \\
    \hline
    7   & class \textit{c} & class \textit{d}, d != c  & high-level relationships between classes, such as \textit{uses} or \textit{consists-of} \\
    \hline
    \end{tabularx}
    \end{center}
    \caption{Types of connections, obtained from \cite{briand1999unified}}
    \label{table:types-connections}
\end{table}

\begin{table}[htb!]
    \begin{center}
    \begin{tabularx}{\textwidth}{|l|l|X|}
    \hline
    \begin{tabular}[c]{@{}l@{}}Counting\\ connections\end{tabular} & Level & Description \\
    \hline\hline
    A   & \begin{tabular}[c]{@{}l@{}}Method or\\ attribute\end{tabular} & count individual connections  \\
     \hline
    B   & \begin{tabular}[c]{@{}l@{}}Method or\\ attribute\end{tabular} & count the number of distinct items at the other end of the connections  \\
     \hline
    C   & Class & add up the number of connections counted as in A) for each method or attribute of the class   \\
     \hline
    D   & Class & add up the number of connections counted as in B) for each method or attribute of the class   \\
     \hline
    E   & Class & count the number of distinct items at the end of connections starting from or ending in methods or attributes of the class    \\
     \hline
    F   & Class & for a class c, count the number of other classes to which there is at least  one connection  \\
    \hline
    \end{tabularx}
    \end{center}
    \caption{Counting connections, obtained from \cite{briand1999unified}}
    \label{table:counting-connections}
\end{table}

\begin{table}[p]
    \begin{center}
    \begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
    \rot{Metric} & \rot{Inheritance} & \rot{Locus of impact} & \rot{Types of connection} & \rot{Domain of measure} & \rot{Counting connections   } & \rot{Indirect coupling} \\ \hline \hline
    CBO           & both  & both    & 5, 6  & class               & F     & no      \\
    CBO'          & no    & both    & 5, 6  & class               & F     & no      \\
    \hline
    $RFC_\alpha$  & both  & import  & 6     & class               & E     & depends \\
    RFC           & both  & import  & 6     & class               & E     & no      \\
    RFC'          & both  & import  & 6     & class               & E     & yes     \\
    \hline
    MPC           & both  & import  & 6     & class               & C     & no      \\
    \hline
    DAC           & both  & import  & 1     & class               & C     & no      \\
    DAC'          & both  & import  & 1     & class               & D     & no      \\
    \hline
    COF           & no    & both    & 5, 6  & system              & F     & no      \\
    \hline
    ICP           & both  & import  & 6     & method, class, set  & A, C  & no      \\
    IH-ICP        & only  & import  & 6     & method, class, set  & A, C  & no      \\
    NIH-ICP       & no    & import  & 6     & method, class, set  & A, C  & no      \\
    \hline
    IFCAIC        & no    & import  & 1     & class               & C     & no      \\
    ACAIC         & only  & import  & 1     & class               & C     & no      \\
    OCAIC         & no    & import  & 1     & class               & C     & no      \\
    FCAEC         & no    & export  & 1     & class               & C     & no      \\
    DCAEC         & only  & export  & 1     & class               & C     & no      \\
    OCAEC         & no    & export  & 1     & class               & C     & no      \\
    \hline
    IFCMIC        & no    & import  & 2     & class               & C     & no      \\
    ACMIC         & only  & import  & 2     & class               & C     & no      \\
    OCMIC         & no    & import  & 2     & class               & C     & no      \\
    FCMEC         & no    & export  & 6     & class               & C     & no      \\
    DCMEC         & only  & export  & 6     & class               & C     & no      \\
    OCMEC         & no    & export  & 6     & class               & C     & no      \\
    \hline
    OMMIC         & no    & import  & 6     & class               & C     & no      \\
    IFMMIC        & no    & import  & 6     & class               & C     & no      \\
    AMMIC         & only  & import  & 6     & class               & C     & no      \\
    OMMEC         & no    & export  & 6     & class               & C     & no      \\
    FMMEC         & no    & export  & 6     & class               & C     & no      \\
    DMMEC         & only  & export  & 6     & class               & C     & no      \\
    \hline
    \end{tabular}
    \end{center}
    \caption{Coupling metrics comparison}
    \label{table:coupling-metrics}
\end{table}


\blankl
Based on this criteria, Briand et al. classify the existing coupling metrics, according to their definitions. The comparison of all the metrics, according to the criteria of the framework can be found in Table \ref{table:coupling-metrics}. The criteria stability of the server has been excluded from the table, since none of the metrics consider it.

\paragraph{Coupling Between Objects (CBO)} This metric counts the number of other classes to which the client class coupled, this metric has two definitions. The original definition, CBO' in Table \ref{table:coupling-metrics}, which does not count inheritance. Then, there is the revised definition of the metric \cite{chidamber1994metrics}, does include inheritance.

\paragraph{Response for Class (RFC)} This metric calculates the response set of a class. According to Chidamber and Kemerer \cite{chidamber1994metrics}, \textit{"The response set of a class is a set of methods that can potentially be executed in response to a message received by an object of that class"}. The return set includes the methods called directly by the class, as well as the methods that are called by transitivity. In the framework by Briand et al. \cite{briand1999unified} it is considered that the inherited methods should be included in this set since they can be executed to respond to a message received in the class. Based on this definition, there are three defined metrics, the first one being $RFC_\alpha$ \cite{churcher1995towards}. The $\alpha$ defines the number of nested levels of transitivity considered in the calculation of the metric. The other two metrics are particular cases of this one: RFC corresponds to when $\alpha = 1$, and RFC' when $\alpha = \infty$.

\paragraph{Message Passing Coupling (MPC)} This metric, originally created by Li and Henry \cite{li1993object}, counts invocations from the new methods of a class to methods of other classes. This means that the inherited methods are not considered, but it is not clear how it treats overridden methods or calls to inherited methods. Briand et al. \cite{briand1999unified}, in order to eliminate ambiguity, redefined the metric as \textit{"the number of static invocations of methods not implemented in c by methods implemented in c"}.

\paragraph{Data Abstraction Coupling (DAC)} This metric was also defined by Li and Henry \cite{li1993object} as follows: \textit{"number of ADTs defined in a class"}, where ADT is abstract data type. However, this definition does not specify how the metric should count the connections, or how to consider inherited ADTs. Because of this ambiguity in the original definition of the metric, Briand et al. \cite{briand1999unified} redefined the metric: \textit{"DAC is the number of not inherited attributes that have a class as their type. The number of the classes used as types for attributes is counted by DAC'"}.

\paragraph{Coupling Factor (COF)} COF is the only metric of which the domain of measurement is the entire system, and was defined by Abreu et al. \cite{abreu1995toward}. COF calculates the number of relations between classes of the system, which are not related through inheritance. The relations are counted in a binary manner. The factor is normalized between 1 and 0 by dividing the number of relations by the maximum number of relations possible in the system. This way, it is possible to compare systems of different sizes.

\paragraph{Information-flow-based Coupling (ICP)} The original ICP metric counts \textit{"for method m of class c, the number of polymorphistically invoked methods of other classes, weighted by the number of parameters of the invoked method."} \cn{lee1995}. From this description, the metrics IH-ICP and NIH-ICP are defined. IH-ICP counts only inheritance-based coupling, whereas NIH-ICP counts coupling to those classes with which there is no inheritance relationship. Finally, the metric ICP is the sum of the previous two.

\paragraph{Suite of metrics by Briand et al.} This set of metrics was defined by Briand et al. with their previous framework for coupling metrics \cite{briand1997investigation}. This framework, was specially created for C++, and therefore, it has some extensions specific for this language.
The metrics of the set are named according to three criteria: relationship, locus, and type. The name of each metric is composed in the following way: the initials of the relationship, the initials of the type of interaction, and the initials of the locus. These initials are described below.

\blankl
There are three types of relationships, listed below, which can be used to determine the coupling of a class $c$. All the definitions have been obtained from \cite{briand1997investigation}.

\begin{itemize}
  \item Inheritance (A, D): Interactions from a class to its antecessors or descendents, depending on the locus.
  \item Friendship (F, IF): Extension for C++, interactions from class to all the  classes declared as friends or the classes that declare it their friend (inverse friends), depending on the locus.
  \item Other (O): interaction with classes that do not have an inheritance or friendship relationship.
\end{itemize}

\blankls
The three different types of interaction descibed by Briand et al. \cite{briand1997investigation}, are the following:
\begin{itemize}
    \item Class-Atribute (CA): "There is a class-attribute (CA-) interaction from class c to class d, if an attribute of class c is of type class d."
    \item Class-Method (CM): "There is a class-method (CM-) interaction from class c to class d, if a newly defined method of class c has a parameter of type class d."
    \item Method-Method (MM): "There is a method-method (MM-) interaction from class c to class d, if a method implemented at class c statically invokes a method of class d (newly defined or overriding), or receives a pointer to such a method."
\end{itemize}

\blankls
Finally, the two types of locus are:
\begin{itemize}
  \item Export from a class (EC): "Change flows away from a class", related to the descendants (D) and the friends (F).
  \item Import to a class (IC): "Change flows towards a class", related to the antecesors (A) and the inverse friends (IF).
\end{itemize}

\blankls
The suite of metrics is defined based on all possible combinations of these three criteria.

\section{Effort measurement}
