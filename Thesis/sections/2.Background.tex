% !TEX root = ..\main.tex
\chapter{Background}\label{ch:Background}
In this chapter we present the background information needed for this thesis. In addition, we also define some terminology that is going to be used in throughout the thesis.

\section{Terminology}

\reminder{This is only to remember the terms from the literature}

\blankl
pashchenko2018

A library is a separately distributed software component,
which typically consists of a logically grouped set of classes
(objects) or methods (functions). To avoid any ambiguity, we
refer to a specific version of a library as a library instance.

A dependency is a library instance, some functionality of
which is used by another library instance (the dependent
library instance).

A dependency is direct if it is directly invoked from the
dependent library instance.

A dependency tree is a representation of a software library
instance and its dependencies where each node is a library
instance and edges connect dependent library instances to
their direct dependencies.

A transitive dependency is connected to the root library instance
of a dependency tree through a path with more than
one edge.

A project is a set of libraries developed and/or maintained
together by a group of developers. Dependencies belonging
to the same project of the dependent library instance are own
dependencies, while library instances maintained by other
projects are third-party dependencies.

A deployed dependency is actually delivered with the application
or system that uses it, while a non-deployed dependency
is only needed at the time of development (e.g., for testing)
but is not a part of the artifact that is eventually released
and operated in a production environment.

\blankl
kikas2017

Packages:
We define packages as a reusable code or set of components that can be included in other applications by using dependency management tools. Packages are published in repositories and are available to everyone.

Applications:
Applications are projects that make use of packages, are not published as a package and thus can not be used in other projects as a dependency.

Versions:
Packages and applications can have multiple versions distinguished by version numbers.

Dependency:
A package can depend on another package. If package A depends on package B we say that A has a dependency (A is a dependent of B) and B has a reverse dependency (B has a dependent). Applications can have dependencies but since they are not published as a reusable package they cannot have reverse dependencies.

Direct or transitive dependency:
A project has a direct dependency if a package on which the project depends, and which it needs to be built, is directly included in the project. A project can have a transitive dependencies on packages that are not needed for the project itself but needed for the direct dependencies included in the project to work. Transitive dependencies can be included through multiple levels of dependencies.

Dependency network:
A dependency network is composed of packages, applications, and dependency relations between them.

Ecosystem:
An ecosystem is the set of packages and applications involved in the dependency network.

\blankl
FASTEN:

Package(Library) is a reusable unit of code with machine-readable information for the package manager. A package usually has many versions which are referred to as releases. In the FASTEN project, a package is referred to as Library in a graph representation. In this report, we will use package and library as interchangeable.

Release(Version) is a specific version of a package. It usually contains a manifest file with metadata. By accessing the manifest file, package manager knows how to identify a release and how to build, configure and deploy it.In the FASTEN projects, it is referred to as Version in a graph representation. In this report, we will use release and version interchangeable.

Package manager is a collection of software tools that can manage the life cycle of packages for software reuse. A package manager can resolve required dependencies as specified in the dependency manifest file (e.g. POM.xml in Maven) and download, install, remove, or upgrade packages accordingly.

Package repository is a central place to store package definitions, metadata, and source codes or binaries. In the FASTEN project, for example Maven Central Repository, Python Package Index, and Ultimate Debian Database are considered package repositories and referred to as Forge in a graph representation.

A dependency is a release that is used by another package release(the dependent release).

\blankl
Halted dependency (pashchenko2018): Dependency in which the server library is no longer updated. This means that if a vulnerability is detected in this library, it will not be fixed.

\blankl
Bloated dependency (soto2020comprehensive): Direct or transitive dependency that is included when compiling the application, but it is not really used by the code of the application.

\blankl
Deployed / non-deployed dependency (pashchenko2018)

\reminder{}

\section{Dependency management}

\section{Dependency Networks}
\subsection{Package Dependency Network (PDN)}
\subsection{Call Dependency Network (CDN)}

\section{Coupling}
When assessing the quality of software, there are many aspects that are considered and measured. One of these, in particular for Object-Oriented systems, is coupling. Coupling measures the degree of dependency between two different parts of a system. In the literature of coupling metrics, these have been used to measure the dependency of the elements of the same system, or to give an overview of the coupling within a system. However, in this thesis we measure the coupling, or degree of dependency, between two different systems.

As described in section \ref{section:scope}, this thesis is focused in the structural metrics, based on static source code analysis.

There are many structural coupling metrics, each one measuring a different type of coupling from a different perspective, depending on the purpose for which the metrics are needed. In order to define type of metric needed to measure the dependency between products, we have used the framework defined by Briand et al. \cite{briand1999unified}, which unifies the frameworks defined by Eder et al. \cite{eder1994coupling}, Hitz and Montazeri \cite{hitz1995measuring}, and Briand et al. \cite{briand1997investigation}.

According to the unified framework defined by Briand et al., the coupling metrics have certain characteristics defining which type of coupling are they measuring. In particular, six criteria are defined:

\begin{itemize}
  \item \textbf{Type of connection:} This criteria defines which mechanism creates coupling, which type of dependency is measured, how the two elements are connected. The different types of connection, as described by Briand et al. \cite{briand1999unified} can be found in Table \ref{table:types-connections}.

  \item \textbf{Locus of impact:} If the coupling is import or export. In other words, if the class for which coupling is being measured is the client or the server of the relationship.

  \item \textbf{Granularity of the measure:} The detail at which the metric calculates coupling. It is defined by 1) The domain at which coupling is measured (e.g. class-level) and 2) how the metric counts the connections (e.g. binary evaluation or counting each one of the connections). The six options to count connections as defined by Briand et al. \cite{briand199unified}, can be found in Table \ref{table:counting-connections}.

  \item \textbf{Stability of the server:} In the framework by Briand et al. the servers are classified as unstable if these are  "subject to development or modification in the project at hand", and stable if these "are not subject to change in the project at hand". The last one includes classes imported from libraries. According to Briand et al., the coupling with an unstable class is represents more risk than coupling with a stable class. However, the studied metrics in the framework do not make use of this criteria, and treat all classes with the same importance.

  \item \textbf{Direct and indirect coupling:} Whether the connection between the two elements is direct, or transitive (there is at least one other element connecting the two). The metrics that do not account for indirect coupling, can be adapted by calculating the transitive closure of the metric.

  \item \textbf{Inheritance:} In this criteria, Briand et al. group the position of the metric respecting special cases such as inheritance and polymorphism.
\end{itemize}

\begin{table}[ht!]
    \begin{center}
    \begin{tabularx}{\textwidth}{|l|l|l|X|}
    \hline
    \# & Client Item & Server Item & Description \\
    \hline\hline
    1   & attribute \textit{a} of a class \textit{c} & class \textit{d}, d != c & class \textit{d} is the type of \textit{a} \\
    \hline
    2   & method \textit{m} of a class \textit{c} & class \textit{d}, d != c  & class \textit{d} is the type of a parameter of \textit{m}, or the return type of \textit{m} \\
    \hline
    3   & method \textit{m} of a class \textit{c} & class \textit{d}, d != c  & class \textit{d} is the type of a local variable of \textit{m} \\
    \hline
    4   & method \textit{m} of a class \textit{c} & class \textit{d}, d != c  & class \textit{d} is the type of a parameter of a method invoked by \textit{m} \\
    \hline
    5   & method \textit{m} of a class \textit{c} & \begin{tabular}[c]{@{}l@{}}attribute \textit{a} of a\\ class \textit{d}, d != c \end{tabular}  & \textit{m} references \textit{a} \\
    \hline
    6   & method \textit{m} of a class \textit{c} & \begin{tabular}[c]{@{}l@{}}method \textit{m'} of a\\ class \textit{d}, d != c \end{tabular} & \textit{m} invokes \textit{m'} \\
    \hline
    7   & class \textit{c} & class \textit{d}, d != c  & high-level relationships between classes, such as \textit{uses} or \textit{consists-of} \\
    \hline
    \end{tabularx}
    \end{center}
    \caption{Types of connections, obtained from \cite{briand1999unified}}
    \label{table:types-connections}
\end{table}

\begin{table}[htb!]
    \begin{center}
    \begin{tabularx}{\textwidth}{|l|l|X|}
    \hline
    \begin{tabular}[c]{@{}l@{}}Counting\\ connections\end{tabular} & Level & Description \\
    \hline\hline
    A   & \begin{tabular}[c]{@{}l@{}}Method or\\ attribute\end{tabular} & count individual connections  \\
     \hline
    B   & \begin{tabular}[c]{@{}l@{}}Method or\\ attribute\end{tabular} & count the number of distinct items at the other end of the connections  \\
     \hline
    C   & Class & add up the number of connections counted as in A) for each method or attribute of the class   \\
     \hline
    D   & Class & add up the number of connections counted as in B) for each method or attribute of the class   \\
     \hline
    E   & Class & count the number of distinct items at the end of connections starting from or ending in methods or attributes of the class    \\
     \hline
    F   & Class & for a class c, count the number of other classes to which there is at least  one connection  \\
    \hline
    \end{tabularx}
    \end{center}
    \caption{Counting connections, obtained from \cite{briand1999unified}}
    \label{table:counting-connections}
\end{table}

\begin{table}[p]
    \begin{center}
    \begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
    \rot{Metric} & \rot{Inheritance} & \rot{Locus of impact} & \rot{Types of connection} & \rot{Domain of measure} & \rot{Counting connections   } & \rot{Indirect coupling} \\ \hline \hline
    CBO           & both  & both    & 5, 6  & class               & F     & no      \\
    CBO'          & no    & both    & 5, 6  & class               & F     & no      \\
    \hline
    $RFC_\alpha$  & both  & import  & 6     & class               & E     & depends \\
    RFC           & both  & import  & 6     & class               & E     & no      \\
    RFC'          & both  & import  & 6     & class               & E     & yes     \\
    \hline
    MPC           & both  & import  & 6     & class               & C     & no      \\
    \hline
    DAC           & both  & import  & 1     & class               & C     & no      \\
    DAC'          & both  & import  & 1     & class               & D     & no      \\
    \hline
    COF           & no    & both    & 5, 6  & system              & F     & no      \\
    \hline
    ICP           & both  & import  & 6     & method, class, set  & A, C  & no      \\
    IH-ICP        & only  & import  & 6     & method, class, set  & A, C  & no      \\
    NIH-ICP       & no    & import  & 6     & method, class, set  & A, C  & no      \\
    \hline
    IFCAIC        & no    & import  & 1     & class               & C     & no      \\
    ACAIC         & only  & import  & 1     & class               & C     & no      \\
    OCAIC         & no    & import  & 1     & class               & C     & no      \\
    FCAEC         & no    & export  & 1     & class               & C     & no      \\
    DCAEC         & only  & export  & 1     & class               & C     & no      \\
    OCAEC         & no    & export  & 1     & class               & C     & no      \\
    \hline
    IFCMIC        & no    & import  & 2     & class               & C     & no      \\
    ACMIC         & only  & import  & 2     & class               & C     & no      \\
    OCMIC         & no    & import  & 2     & class               & C     & no      \\
    FCMEC         & no    & export  & 6     & class               & C     & no      \\
    DCMEC         & only  & export  & 6     & class               & C     & no      \\
    OCMEC         & no    & export  & 6     & class               & C     & no      \\
    \hline
    OMMIC         & no    & import  & 6     & class               & C     & no      \\
    IFMMIC        & no    & import  & 6     & class               & C     & no      \\
    AMMIC         & only  & import  & 6     & class               & C     & no      \\
    OMMEC         & no    & export  & 6     & class               & C     & no      \\
    FMMEC         & no    & export  & 6     & class               & C     & no      \\
    DMMEC         & only  & export  & 6     & class               & C     & no      \\
    \hline
    \end{tabular}
    \end{center}
    \caption{Coupling metrics comparison}
    \label{table:coupling-metrics}
\end{table}


\blankl
Based on this criteria, Briand et al. classify the existing coupling metrics, according to their definitions. The comparison of all the metrics, according to the criteria of the framework can be found in Table \ref{table:coupling-metrics}. The criteria stability of the server has been excluded from the table, since none of the metrics consider it.

\paragraph{Coupling Between Objects (CBO)} This metric counts the number of other classes to which the client class coupled, this metric has two definitions. The original definition, CBO' in Table \ref{table:coupling-metrics}, which does not count inheritance. Then, there is the revised definition of the metric \cite{chidamber1994metrics}, does include inheritance.

\paragraph{Response for Class (RFC)} This metric calculates the response set of a class. According to Chidamber and Kemerer \cite{chidamber1994metrics}, \textit{"The response set of a class is a set of methods that can potentially be executed in response to a message received by an object of that class"}. The return set includes the methods called directly by the class, as well as the methods that are called by transitivity. In the framework by Briand et al. \cite{briand1999unified} it is considered that the inherited methods should be included in this set since they can be executed to respond to a message received in the class. Based on this definition, there are three defined metrics, the first one being $RFC_\alpha$ \cite{churcher1995towards}. The $\alpha$ defines the number of nested levels of transitivity considered in the calculation of the metric. The other two metrics are particular cases of this one: RFC corresponds to when $\alpha = 1$, and RFC' when $\alpha = \infty$.

\paragraph{Message Passing Coupling (MPC)} This metric, originally created by Li and Henry \cite{li1993object}, counts invocations from the new methods of a class to methods of other classes. This means that the inherited methods are not considered, but it is not clear how it treats overridden methods or calls to inherited methods. Briand et al. \cite{briand1999unified}, in order to eliminate ambiguity, redefined the metric as \textit{"the number of static invocations of methods not implemented in c by methods implemented in c"}.

\paragraph{Data Abstraction Coupling (DAC)} This metric was also defined by Li and Henry \cite{li1993object} as follows: \textit{"number of ADTs defined in a class"}, where ADT is abstract data type. However, this definition does not specify how the metric should count the connections, or how to consider inherited ADTs. Because of this ambiguity in the original definition of the metric, Briand et al. \cite{briand1999unified} redefined the metric: \textit{"DAC is the number of not inherited attributes that have a class as their type. The number of the classes used as types for attributes is counted by DAC'"}.

\paragraph{Coupling Factor (COF)} COF is the only metric of which the domain of measurement is the entire system, and was defined by Abreu et al. \cite{abreu1995toward}. COF calculates the number of relations between classes of the system, which are not related through inheritance. The relations are counted in a binary manner. The factor is normalized between 1 and 0 by dividing the number of relations by the maximum number of relations possible in the system. This way, it is possible to compare systems of different sizes.

\paragraph{Information-flow-based Coupling (ICP)} The original ICP metric counts \textit{"for method m of class c, the number of polymorphistically invoked methods of other classes, weighted by the number of parameters of the invoked method."} \cn{lee1995}. From this description, the metrics IH-ICP and NIH-ICP are defined. IH-ICP counts only inheritance-based coupling, whereas NIH-ICP counts coupling to those classes with which there is no inheritance relationship. Finally, the metric ICP is the sum of the previous two.

\paragraph{Suite of metrics by Briand et al.} This set of metrics was defined by Briand et al. with their previous framework for coupling metrics \cite{briand1997investigation}. This framework, was specially created for C++, and therefore, it has some extensions specific for this language.
The metrics of the set are named according to three criteria: relationship, locus, and type. The name of each metric is composed in the following way: the initials of the relationship, the initials of the type of interaction, and the initials of the locus. These initials are described below.

\blankl
There are three types of relationships, listed below, which can be used to determine the coupling of a class $c$. All the definitions have been obtained from \cite{briand1997investigation}.

\begin{itemize}
  \item Inheritance (A, D): Interactions from a class to its antecessors or descendents, depending on the locus.
  \item Friendship (F, IF): Extension for C++, interactions from class to all the  classes declared as friends or the classes that declare it their friend (inverse friends), depending on the locus.
  \item Other (O): interaction with classes that do not have an inheritance or friendship relationship.
\end{itemize}

\blankls
The three different types of interaction descibed by Briand et al. \cite{briand1997investigation}, are the following:
\begin{itemize}
    \item Class-Atribute (CA): "There is a class-attribute (CA-) interaction from class c to class d, if an attribute of class c is of type class d."
    \item Class-Method (CM): "There is a class-method (CM-) interaction from class c to class d, if a newly defined method of class c has a parameter of type class d."
    \item Method-Method (MM): "There is a method-method (MM-) interaction from class c to class d, if a method implemented at class c statically invokes a method of class d (newly defined or overriding), or receives a pointer to such a method."
\end{itemize}

\blankls
Finally, the two types of locus are:
\begin{itemize}
  \item Export from a class (EC): "Change flows away from a class", related to the descendants (D) and the friends (F).
  \item Import to a class (IC): "Change flows towards a class", related to the antecesors (A) and the inverse friends (IF).
\end{itemize}

\blankls
The suite of metrics is defined based on all possible combinations of these three criteria.

\section{Effort measurement}
