% !TEX root = ../main.tex
\chapter{Introduction}\label{ch:Introduction}

\section{Problem statement}

\subsection{Context}
Currently, there are many open-source libraries available for developers to reuse the features that these libraries implement. This practice is becoming more and more popular since it allows the reuse of previously developed code and helps developers avoid implementing the same functionalities multiple times.

When a developer uses an open-source library in a project, it creates a dependency between the project and the library. This implies that a significant number of projects depend on other open-source projects, and it adds the task of managing these dependencies to the maintenance tasks of the project. Proper maintenance of the dependencies of a project is also part of the health and security of software applications, and it is one of the problems that the field of software engineering is trying to solve \cite{kula2014visualizing}. For instance, an update of a dependency can involve changing part of the code, if the update contains breaking changes \cite{Raemaekers2017}.

The management and maintenance of the dependencies of a project is an important task. External libraries, just like any other software product, can have security vulnerabilities that may affect the projects that depend on these libraries. For example, some vulnerabilities can become security problems that can have a negative impact in terms of integrity, privacy, or availability.

\blankl
Currently, developers have package managers at their disposal, to ease the task of managing the dependencies of their projects. However, the dependency management available in these package managers only evaluates if a dependency exists or not and a more detailed evaluation is missing \cite{hejderup2018prazi}. For instance, there is no way to evaluate how much a project depends on a library.

\blankl
Therefore, this thesis aims to create a model to evaluate the dependencies, in order to obtain information of the \textit{actual usage} of the dependencies. A set of metrics is proposed to measure the dependencies between projects and the dependencies these have. The metrics are designed to evaluate the dependencies according to two different perspectives, the code affected by the dependency, and how much of a dependency is used.

\subsection{Host organization}
This project has been carried out in collaboration with the company \textit{Software Improvement Group (SIG)}, and it is motivated by the \textit{FASTEN} project \footnote{\url{https://www.fasten-project.eu/}}. The objective of this project is to improve the quality of open-source development environments to make them more secure and reliable. For this reason, the FASTEN project aims to analyze the software library dependencies that the projects have in more detail.

\subsection{Research questions}
\discussion{Still deciding whether to use software product, or libraries, how to introduce it. Because, for the PoC I am using only libraries available in Maven, but the model is meant to be used to measure the dependencies with any type of software product}
To tackle the problems described in the previous section, we specify the following research questions:

\blankl
\textbf{RQ1:} \textit{How can we measure the degree of code dependency between two software products with a direct dependency?}

\blankls
With this question, we want to propose a set of metrics to measure a dependency from the point of view of the product that has a dependency with another product. How much it is affected by the dependency.

\begin{itemize}
  \item \textbf{RQ1.1:} \textit{What constitutes a dependency between two products?}

  First, we need to determine what creates a dependency. The type of connection between the products and how can it be measured.

  \item \textbf{RQ1.2:} \textit{Which metrics can be used to measure the dependency?}

  We propose metrics to measure the dependency described. Existing metrics are considered, as well as new ones.

  \item \textbf{RQ1.3:} \textit{How can the proposed metrics be validated?}

  There are many different approaches to validate metrics, some of which are used to carry out the validation of the proposed metrics.
\end{itemize}

\blankl
\textbf{RQ2:} \textit{How can we measure the degree of code dependency between two software products with a transitive dependency?} \unsure{I'm not sure if I should phrase this question like this, or focusing on the differences: How should the measurements of the dependencies be adapted for the case of transitive dependencies}

\blankls
Transitive dependencies involve more factors than direct dependencies. Therefore, the metrics proposed for the direct dependencies have to be adapted for the transitive ones.

\blankl
\textbf{RQ3:} \textit{How can we measure how much is a dependency used by a software product?}

\blankls
For this question, we look at the dependency from a different perspective. In this case, we measure how much of the dependency is being used by the software product.

\blankl
\textbf{RQ4:} \textit{How can we visualize the metrics designed to model the software dependencies?}

\blankls
We present a few visualizations to see the metrics of the model. The visualizations are presented to software developers to discuss the usefulness and actionability.

\subsection{Research method}
The main research method that is going to be employed during this project is \textit{Technical Action Research} (TAR) \cite{wieringa2012technical}.
This research method is artifact-based, which means that the first step is to produce the artifact meant to be used in certain situations envisioned by the researcher. The testing of this artifact, to see if it is effective in these situations, is done through a number of iterations. First, under ideal conditions, and then changing the experiments step by step to reach a real-world situation. In the context of this master thesis, because of time constraints, performing multiple iterations is not possible. However, there is the option of continuing with this part of the work in the future.

\blankl
In addition, the research will also include experiments. These experiments will be conducted as the empirical part of the validation of the metrics and the proof-of-concept implementation of the model and the visualizations.

\section{Contributions}
Considering the current state of the art in the domain of this thesis project, the main contributions made by this research are the following:

\begin{enumerate}
	\item Creating a model for software dependencies including both, direct and transitive dependencies of a software product. The model includes modified coupling metrics to measure the coupling between two different software products, redefining the meaning and usage of the metrics.
  \blankls

	\item Evaluation and validation of the proposed metrics and model, by the means of a proof-of-concept tool to calculate the metrics.

  \item A proposed visualization of the model, validated through expert review.
\end{enumerate}

\section{Scope}\label{section:scope}

In this research we propose a model for software dependencies, containing metrics to measure different aspects of the dependencies. We develop a proof-of-concept tool to calculate and visualize the model.

\subsection{Quantifying the dependencies}
To the best of our knowledge, there are no papers about measuring the degree of dependency between two separate projects. However, the degree of dependency between two classes or modules of the same project has already been measured many times, using coupling metrics \cite{briand1999unified}.

Therefore, we propose re-using the already existing coupling metrics, meant to measure the coupling between units of the \textit{same} project and adapt them to measure coupling \textit{between} projects.

\blankl
According to Poshyvanyk and Marcus in \cite{poshyvanyk2006conceptual}, there are six main groups of coupling metrics:

\begin{itemize}
  \item \textbf{Structural coupling metrics:} Measured directly from static source code analysis. Largely studied by the literature about coupling.

  \item \textbf{Dynamic coupling measures:} Measured using dynamic code analysis. \textit{"Introduced as the refinement to existing coupling measures due to gaps in addressing polymorphism, dynamic binding, and the presence of unused code by static structural coupling measures"} \cite{poshyvanyk2006conceptual}.

  \item \textbf{Evolutionary and Logical coupling:} According to Zimmermann and Diehl \cite{zimmermann2005mining}, evolutionary coupling can: \textit{"tell us which parts of the system are coupled by common changes or cochanges."}

  \item \textbf{Coupling measures based on information entropy approach:} Coupling metrics based on the information-theory approach, such as the metrics proposed by Allen and Khoshgoftaar in \cite{allen1999measuring}.

  \item \textbf{Conceptual coupling metrics:} Based on the semantic similarity between the elements. This is the focus of the work from Poshyvanyk and Marcus \cite{poshyvanyk2006conceptual}.

  \item \textbf{Coupling metrics for specific types of software applications:} Specialized coupling metrics for certain types of projects, such as knowledge-based systems or aspect-oriented approach.
\end{itemize}

\blankl
Since this research is aimed to be independent of the domain, the last category is not considered in this thesis. Moreover, the evolutionary coupling is not possible to be applied in our context. It is very likely that the separate projects are not going to evolve at the same time, given that they are not developed by the same team. Finally, the research of this project, owing to the time limitation, is going to be centered on the structural metrics.

These metrics are going to be proposed as a first step to measure the degree of library dependency. Nevertheless, the metrics can be extended and calculated more accurately by adding dynamic coupling and information entropy approach metrics in future work.

\subsection{Proof-of-concept}
The model proposed in this research is meant to be language-agnostic. Nevertheless, the scope of the proof-of-concept is limited to Java, since the bytecode analysis performed by the proof-of-concept is limited to this programming language.

Besides, since the implementation performs bytecode analysis on jar files obtained from \textit{Maven Repository Central}, the testing dependencies are out of the scope of the proof-of-concept. Generally, the testing classes are not included in the jar files of the Maven artifacts.

\subsection{Evaluation and validation}
This thesis includes the evaluation and validation of the metrics included in the proposed model by using the proof-of-concept. Since there is not a unique way to validate metrics which is globally accepted and used various approaches are adopted. In the paper \cite{srinivasan2014software}, Srinivasan et al. explain that there are two fundamental approaches for metric validation: \textit{theoretically} and \textit{empirically}. Therefore, to provide a check of validity that is as broad as possible, a mixture of these two approaches will be used during this project. However, this research does not contain a full validation of the metrics, due to time constraints.

For the theoretical validity of the coupling metrics, these are validated according to the \textit{Mathematical Properties of Measures for Coupling} \cite{srinivasan2014software}. Also, a subset of the aspects presented by Meenely et al. \cite{meneely2013validating} are also used to validate all the metrics in the model.
The empirical validation of the metrics is carried out by the means of case studies, comparing the impact that breaking changes in the APIs of a library has in the dependant projects with the measured metrics.

\section{Outline}
In Chapter \ref{ch:Background} we describe the background of this thesis based on the existing literature of the domain.
Chapter \ref{ch:TheoreticModel} describes the metrics used to model the dependencies between software products.
The theoretic model is used in Chapter \ref{ch:PoC}, which describes the creation of the proof-of-concept of this model.
In Chapter \ref{ch:Experiments}, the set up and execution of the experiments is explained, and the results of the experiments are shown. These results are discussed in Chapter \ref{ch:Discussion}. Chapter \ref{ch:RelatedWork}, contains the work related to the domain of this thesis.
Finally, we present our concluding remarks in Chapter \ref{ch:Conclusion}, as well as future work.
