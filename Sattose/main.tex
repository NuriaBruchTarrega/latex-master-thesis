\documentclass[a4paper]{article}
\usepackage{graphicx}
\usepackage{twocolpceurws}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}



\title{Measuring the degree of library dependency}

\author{
Núria Bruch Tàrrega \\ Universtiy of Amsterdam \\ nuria.bruchtarrega@student.uva.nl
\and
John X. Ceur \\ Science Dept.\\
                Online City, CEUR 99099 \\ jqq@ceur-ws.org
\and
Yvonne Onderzoeker \\ Research Dept.\\
                Science City, Sci 88088 \\ yvo@science.rdept.net
}

\institution{}




\begin{document}
\maketitle

\begin{abstract}
This is the abstract
\end{abstract}


\section{Introduction}
At present, there are many open-source libraries available for all developers to reuse the features that these libraries implement. This practice is becoming more and more popular since it allows to reuse previously developed code, and helps developers avoid implementing the same functionalities multiple times.

When a developer uses an open-source library in a project, it creates a dependency between the application and the library. This implies that a significant number of projects depend on other open-source projects, and it adds the task of managing these dependencies to the maintenance tasks of the project. How to maintain the dependencies is not a trivial task, and it is one of the problems that the field of software engineering is trying to solve \cite{kula2014visualizing}.

The management and maintenance of the dependencies of a project is an important task. Open-source libraries, just like any other software project, can have security vulnerabilities that may affect the projects that depend on these libraries. For example, some vulnerabilities can become security problems that can have a negative impact in terms of integrity, privacy or availability.

Currently, developers have at their disposal package managers, to ease the task of managing the dependencies of their projects. However, the dependency management available in these package managers only evaluate if a dependency exists or not and a more detailed risk evaluation is missing \cite{hejderup2018prazi}. There is no way to evaluate how much a project depends on a library.

Furthermore, it could happen that the developers of a project decide to replace one of the dependencies of the project with another one. This could happen in case a library has vulnerabilities or is deprecated, to prevent the vulnerabilities from affecting the project. However, replacing a dependency could be a costly process. It involves identifying which parts of the project are affected by the dependency, and which parts of the library are being used and need replacement.

Therefore, this thesis has the aim to perform a more detailed evaluation of the dependencies. A set of metrics is proposed to measure the dependencies between projects and the open-source libraries these use. In addition, we want to propose a way to measure the effort that would be required to replace a dependency with a new one. We are going to define a method to estimate effort considering which parts of the code are affected by the dependency.

\subsection{Research questions}
Based on the problem statement described, we define the following research questions:

\begin{itemize}[noitemsep]
  \item \textbf{RQ1:} \textit{How can we measure the degree of source code dependency between two libraries?}

  The goal of this research question is to define the metrics to measure a dependency. We focus on coupling metrics, which have been used for many years, in particular for Object-Oriented systems.

  \item \textbf{RQ2:} How can we measure the effort required to replace a dependency with another dependency with a different library?
\end{itemize}

\section{Background}
There are six main groups of coupling metrics \cite{poshyvanyk2006conceptual}: structural, dynamic, evolutionary and logical, information entropy approach, conceptual, and domain-specific. The most largely studied by the literature is the structural coupling, and it is the type of coupling measured in this research.

Briand et al. \cite{briand1999unified} defined a unified framework for coupling metrics, based on three previously existing frameworks. In their work, they specify are six criteria that define the type of coupling that a metric calculates. 1) The type of connection, which is the mechanism that creates coupling. 2) The locus of impact, or from which element of the relationship is the coupling being measured: the one that uses another element (import), or the one that is being used (export). 3) The granularity of the measure, which includes two aspects: the domain level (e.g. method, class, system), and how the metric counts the connections between the two elements (e.g. count each connection individually or binary evaluation of the connection between two elements). 4) The stability of the server, the server represents the element used by the other one in the relationship. The stability of the server is determined by the element being or not subject to modifications in the project at hand. 5) Direct/Indirect coupling, if the metric accounts for indirect relationships, or only measures the direct ones. 6) Inheritance, this criterion specifies how certain special cases (e.g. inheritance and polymorphism) affect the coupling between two elements.

\section{Related Work}
Soto-Valero et al. \cite{soto2020comprehensive} conducted a study of bloated dependencies. Bloated dependencies are included in the dependency set of a project, either direct or transitive, but there is no real dependency since the libraries are unused. They developed the tool \textit{DepClean}, which analyses the dependencies of Java artifacts, to define which are bloated and to generate an alternative dependency file without bloated dependencies. Pashchenko et al. \cite{pashchenko2018vulnerable} propose a method to analyze dependencies in which they distinguish between own and third-party libraries, as well as deployed and non-deployed dependencies. In addition, they remark the increased risk related to halted dependencies, since the libraries related to these dependencies are not updated.

Hejderup et al. \cite{hejderup2018software} propose a technique to represent software ecosystems at a function level, a versioned call based dependency network. This call-level dependency graph, in contrast with a package-level dependency graph, allows performing a more detailed evaluation of the dependencies. The graph is used to analyze how the bugs and vulnerabilities spread across the dependency network. In another study Hejderup et al. \cite{hejderup2018software} define an approach, named Präzi, to generate call-level dependency networks. In particular, they implement this approach for the Rust ecosystem and discuss all the perils affecting the soundness and precision of Präzi. They conclude that RustPräzi is three times more precise than the package-level dependency graphs.

\section{Dependency evaluation model}
To define the metrics to be used, we have evaluated the six criteria previously described to formulate the definition of coupling that we want to measure. As described in the introduction, the coupling will be measured at a library level, with the goal of measuring each one of the connections (criterion 3). The coupling is evaluated from the point of view of the library that depends on another one (import, criterion 2). With this project, we want to evaluate two types of dependencies: direct and transitive, therefore there will be different metrics for both types of coupling (criterion 5). Since the third-party libraries are unlikely to be modified because of the evaluated library, the server is stable (criterion 4). % Here it is missing criteria 1 and 6. Which still have to be discussed.


\section{Evaluation Setup}
% We are going to develop a proof-of-concept tool in order to calculate the proposed metrics to measure the dependencies. In this tool, the metrics are going to be calculated from call-level dependency graphs, which will contain the dependency network of the evaluated library.


\section{Preliminary Results}



\section{Conclusion}

\subsection{Next steps}


\bibliographystyle{alpha}
\bibliography{res}
%inline the .bbl file directly for mailing to authors.

\end{document}
